<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>–ù–∞–≤—ñ–≥–∞—Ü—ñ—è –º–∞—Ä—à—Ä—É—Ç–æ–º</title>

  <!-- Mapbox -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- Turf -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- LZ-String (–¥–ª—è srcz) -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <!-- NoSleep.js (fallback –¥–ª—è iOS/—Å—Ç–∞—Ä–∏—Ö –±—Ä–∞—É–∑–µ—Ä—ñ–≤, —è–∫—â–æ Wake Lock API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π) -->
  <script src="https://cdn.jsdelivr.net/npm/nosleep.js@0.12.0/dist/NoSleep.min.js"></script>

  <!-- Firebase (auth) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <!-- App config -->
  <script src="/config/config.js"></script>

  <style>
    :root { --card:#fff; --line:#e5e7eb; --muted:#6b7280; --accent:#2563eb; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #map { position:fixed; inset:0; }
    .topbar { position:fixed; left:0; right:0; top:0; height:64px; display:flex; align-items:center; gap:12px; padding:8px 12px; background:rgba(255,255,255,.85); backdrop-filter: blur(8px); box-shadow:0 1px 0 var(--line); z-index:10; }
    .title { font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .stats { display:flex; gap:8px; font-size:16px; color:#111; }
    .pill { background:#f3f4f6; border:1px solid var(--line); padding:4px 8px; border-radius:999px; }
  .controls { margin-left:auto; display:flex; gap:8px; }
    button { height:40px; padding:0 12px; border-radius:10px; border:1px solid var(--line); background:var(--card); cursor:pointer; font-weight:600; }
    .primary { background:var(--accent); color:#fff; border-color:#1d4ed8; }
  .fab { position:fixed; right:12px; bottom:calc(env(safe-area-inset-bottom) + 12px); z-index:10040; display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
  .fab button { background:#fff; width:48px; height:48px; border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.15); border:1px solid var(--line); }
  .fab .fab-menu{ display:none; position:relative; }
  .fab.open .fab-menu{ display:flex; flex-direction:column; gap:8px; }
  .fab #fabToggle{ font-size:20px; }
    .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#111; color:#fff; padding:10px 14px; border-radius:10px; display:none; z-index:20; }
    .notice{
      position:fixed; left:12px; right:12px;
      bottom:calc(env(safe-area-inset-bottom) + 12px);
      background:rgba(17,24,39,.9); color:#fff;
      padding:8px 12px; border-radius:12px;
      font-size:13px; line-height:1.35; display:none; z-index:20;
      pointer-events:none;
    }
    /* –ü–æ—Ä—Ç—Ä–µ—Ç–Ω–∏–π —Ä–µ–∂–∏–º: –∑—Ä–æ–±–∏—Ç–∏ –≤–µ—Ä—Ö–Ω—é –ø–∞–Ω–µ–ª—å –±–∞–≥–∞—Ç–æ—Ä—è–¥–∫–æ–≤–æ—é */
    @media (max-width: 600px) {
      .topbar { height:auto; flex-wrap:wrap; gap:6px 8px; align-items:flex-start; padding-bottom:8px; }
      .title { order:1; flex:1 1 100%; }
      .stats { order:2; flex:1 1 100%; gap:6px; font-size:14px; }
      .controls { order:3; flex:1 1 100%; display:flex; flex-wrap:wrap; gap:6px; }
      .controls button { flex:1 1 calc(50% - 6px); height:36px; padding:0 8px; font-size:13px; }
    }
    /* –ü–ª–∞–≤–∞—é—á–∏–π –∫—Ä—É–∂–µ—á–æ–∫ —à–≤–∏–¥–∫–æ—Å—Ç—ñ */
    .speed-badge{
      position:fixed; right:12px; bottom:calc(env(safe-area-inset-bottom) + 92px);
      width:56px; height:56px; border-radius:50%; background:#fff; color:#111;
      border:1px solid var(--line); display:grid; place-items:center;
      font-weight:800; font-size:18px; z-index:10050; user-select:none;
      touch-action:none; cursor:grab; box-shadow:0 2px 8px rgba(0,0,0,.18);
    }
    .speed-badge:active{ cursor:grabbing; }
    /* –ü–ª–∞–≤–∞—é—á–∏–π —è—Ä–ª–∏—á–æ–∫ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞–Ω–µ–≤—Ä—É */
    .turn-badge{
      position:fixed; left:12px; bottom:calc(env(safe-area-inset-bottom) + 92px);
      width:56px; height:56px; border-radius:50%; background:#fff; color:#111;
      border:1px solid var(--line); display:grid; place-items:center;
      font-weight:800; font-size:22px; z-index:10050; user-select:none;
      touch-action:none; cursor:grab; box-shadow:0 2px 8px rgba(0,0,0,.18);
    }
    .turn-badge:active{ cursor:grabbing; }
    .turn-badge .turn-arrow{ width:44px; height:44px; transform-origin:50% 50%; transition: transform .15s ease; }
    .turn-badge .turn-dist{
      position:absolute; top:calc(100% + 4px); left:50%; transform:translateX(-50%);
      background:#fff; color:#111; border:1px solid var(--line); border-radius:10px;
      padding:3px 8px; font-weight:800; font-size:16px; line-height:1; white-space:nowrap;
      box-shadow:0 1px 4px rgba(0,0,0,.12); user-select:none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <div class="title" id="routeTitle">–ù–∞–≤—ñ–≥–∞—Ü—ñ—è</div>
    <div class="stats">
      <div class="pill" id="statDistance">‚Äî –∫–º</div>
      <div class="pill" id="statEta">ETA ‚Äî</div>
      <div class="pill" id="statMode">driving</div>
    </div>
    <div class="controls">
      <button id="btnStart" class="primary">–°—Ç–∞—Ä—Ç</button>
      <button id="btnStop">–°—Ç–æ–ø</button>
      <button id="btnShare">–ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è</button>
      <button id="btnKeepAwake" title="–ù–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω">–ù–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω</button>
    </div>
  </div>

  <div class="fab" id="fab">
    <div class="fab-menu" id="fabMenu">
      <button id="btnRecenter" title="–°—Ç–µ–∂–µ–Ω–Ω—è: —É–≤—ñ–º–∫–Ω–µ–Ω–æ">üîí</button>
      <button id="fabKeepAwake" title="–ù–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω">üí°</button>
      <button id="btnEtaMode" title="–†–µ–∂–∏–º ETA: –ø–ª–∞–Ω">‚è±</button>
      <button id="btnTraffic" title="–°–≤—ñ—Ç–ª–æ—Ñ–æ—Ä–∏: –≤–∏–∫–ª">üö¶</button>
    </div>
    <button id="fabToggle" title="–î—ñ—ó">‚ãÆ</button>
  </div>

  <div class="toast" id="toast">–°–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ</div>
  <div class="notice" id="notice">–î–ª—è –≥–æ–ª–æ—Å–æ–≤–∏—Ö –ø—ñ–¥–∫–∞–∑–æ–∫ –∑–∞–ª–∏—à–∞–π —Ü—é —Å—Ç–æ—Ä—ñ–Ω–∫—É –≤—ñ–¥–∫—Ä–∏—Ç–æ—é –Ω–∞ –µ–∫—Ä–∞–Ω—ñ. –£ —Ñ–æ–Ω–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ –±—Ä–∞—É–∑–µ—Ä –º–æ–∂–µ –∑—É–ø–∏–Ω—è—Ç–∏ GPS/–∑–≤—É–∫.</div>
  <div id="speedBadge" class="speed-badge" title="–®–≤–∏–¥–∫—ñ—Å—Ç—å, –∫–º/–≥–æ–¥">0</div>
  <div id="turnBadge" class="turn-badge" title="–ù–∞—Å—Ç—É–ø–Ω–∏–π –º–∞–Ω–µ–≤—Ä">
    <svg id="turnArrow" class="turn-arrow" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
      <!-- –¢–æ–≤—Å—Ç–∞ —Å—Ç—Ä—ñ–ª–∫–∞ –≤–≥–æ—Ä—É; –±—É–¥–µ–º–æ –æ–±–µ—Ä—Ç–∞—Ç–∏ –≤–µ—Å—å SVG -->
      <path fill="#111827" d="M32 6 L50 26 L38 26 L38 50 L26 50 L26 26 L14 26 Z"/>
    </svg>
    <span id="turnText" style="display:none; font-size:20px; line-height:1">‚Üë</span>
    <div id="turnDist" class="turn-dist" aria-label="–í—ñ–¥—Å—Ç–∞–Ω—å –¥–æ –º–∞–Ω–µ–≤—Ä—É" style="display:none">‚Äî</div>
  </div>

<script>

(async function(){
  // ===== Auth gate (redirect to /login.html unless public/guest allowed) =====
  const qs = new URLSearchParams(location.search);
  const allowGuest = qs.has('guest') || qs.get('public') === '1';

  // –ß–µ–∫–∞—î–º–æ –Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∫–æ–Ω—Ñ—ñ–≥—É
  function waitForConfig(){
    return new Promise(resolve => {
      if (window.APP_CONFIG?.firebase && window.APP_CONFIG?.mapboxToken) return resolve();
      const check = setInterval(() => {
        if (window.APP_CONFIG?.firebase && window.APP_CONFIG?.mapboxToken) {
          clearInterval(check);
          resolve();
        }
      }, 20);
    });
  }
  await waitForConfig();

  if (!allowGuest) {
    const CFG = window.APP_CONFIG.firebase;
    try{
      const app = firebase.apps?.length ? firebase.app() : firebase.initializeApp(CFG);
      const auth = firebase.auth();
      await new Promise((resolve) => {
        auth.onAuthStateChanged(u => {
          if (u) resolve();
          else {
            const next = encodeURIComponent(location.pathname + location.search);
            location.replace(`/login.html?next=${next}`);
          }
        });
      });
    }catch(e){
      const next = encodeURIComponent(location.pathname + location.search);
      location.replace(`/login.html?next=${next}`);
      return;
    }
  }
  // ===== /Auth gate =====

  const MAPBOX_TOKEN = qs.get('token') || window.APP_CONFIG.mapboxToken || '';
  const PROFILE = qs.get('profile') || 'driving';
  const SRCZ = qs.get('srcz');               // —Å—Ç–∏—Å–Ω–µ–Ω–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
  const SRC_B64 = qs.get('src');             // fallback
  const AUTO_START = qs.has('autostart') ? (qs.get('autostart') === '1') : true;

  // === CAMERA / TRACK-UP ===
  const NAV_PITCH_DEG  = 60;
  const NAV_OFFSET_PX  = 180;
  const NAV_MIN_ZOOM   = 15;
  const CAMERA_DURATION = 300; // —à–≤–∏–¥–∫–∞ –∞–Ω—ñ–º–∞—Ü—ñ—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –≤—ñ–¥–≥—É–∫—É
  const MARKER_ROT_OFFSET = -90; // –∫–æ–º–ø–µ–Ω—Å—É—î–º–æ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é SVG, —â–æ–± —Å—Ç—Ä—ñ–ª–∫–∞ –≤–∫–∞–∑—É–≤–∞–ª–∞ –ø–æ –∫—É—Ä—Å—É

  // === GPS smoothing & snap ===
  const GPS_ACCURACY_MAX = 50;
  const SMOOTH_ALPHA_POS = 0.45; // –±–∞–∑–æ–≤–µ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó
  const SMOOTH_ALPHA_HD  = 0.6;  // –¥–ª—è –∫–æ–º–ø–∞—Å—É/–∫—É—Ä—Å—É
  const SNAP_MAX_METERS  = 40;
  // –ö–µ—Ä—É–≤–∞–Ω–Ω—è —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—Å—Ç—é –∫–∞–º–µ—Ä–∏, –∫–æ–ª–∏ —Å—Ç–æ—ó–º–æ –Ω–∞ –º—ñ—Å—Ü—ñ
  const STATIONARY_SPEED_MPS = 0.7;           // –Ω–∏–∂—á–µ —Ü—å–æ–≥–æ ‚Äî –≤–≤–∞–∂–∞—î–º–æ, —â–æ —Å—Ç–æ—ó–º–æ
  const MIN_MOVE_FOR_HEADING_M = 2.5;         // –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —Ä—É—Ö, —â–æ–± –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –∫—É—Ä—Å
  const BEARING_DEADBAND_DEG = 8;             // ¬´–º–µ—Ä—Ç–≤–∞ –∑–æ–Ω–∞¬ª –¥–ª—è –¥—Ä—ñ–±–Ω–∏—Ö –∫–æ–ª–∏–≤–∞–Ω—å

  // === Voice timing ===
  const SPEAK_LOOKAHEAD_SEC = 8;
  const SPEAK_MIN_DIST = 60;
  const SPEAK_MAX_DIST = 800;
  const SPEAK_NOW_DIST = 25;
  const SPEAK_MIN_GAP_MS = 6000; // –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª –º—ñ–∂ –ø—ñ–¥–∫–∞–∑–∫–∞–º–∏


  // === –£–∑–¥–æ–≤–∂-–º–∞—Ä—à—Ä—É—Ç–Ω–µ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è (–ø–æ–∑–∏—Ü—ñ—è –Ω–∞ –ª—ñ–Ω—ñ—ó) ===
  // 1D alpha-beta —Ñ—ñ–ª—å—Ç—Ä –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ñ –≤–∑–¥–æ–≤–∂ –º–∞—Ä—à—Ä—É—Ç—É (–≤ –∫—ñ–ª–æ–º–µ—Ç—Ä–∞—Ö)
  const TRACK_ALPHA = 0.25;     // –Ω–∞—Å–∫—ñ–ª—å–∫–∏ –¥–æ–≤—ñ—Ä—è—î–º–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—é
  const TRACK_BETA  = 0.05;     // –Ω–∞—Å–∫—ñ–ª—å–∫–∏ –∫–æ—Ä–∏–≥—É—î–º–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å
  const MAX_KPS     = 0.07;     // –º–∞–∫—Å. —à–≤–∏–¥–∫—ñ—Å—Ç—å, –∫–º/—Å (~252 –∫–º/–≥–æ–¥)

  function b64decodeUtf8(b64){
    const bin = atob(b64); const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function b64encodeUtf8(objOrString){
    const s = typeof objOrString === 'string' ? objOrString : JSON.stringify(objOrString);
    const bytes = new TextEncoder().encode(s); let bin = '';
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
  }

  if (!MAPBOX_TOKEN){
    alert('–í—ñ–¥—Å—É—Ç–Ω—ñ–π Mapbox token. –î–æ–¥–∞–π –π–æ–≥–æ —É navigate.html –∞–±–æ ?token=...');
  }
  mapboxgl.accessToken = MAPBOX_TOKEN;

  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [30.523, 50.45],
    zoom: 12,
    pitch: 45,
    attributionControl: true
  });
  map.addControl(new mapboxgl.NavigationControl({visualizePitch:true}), 'bottom-left');

  function applyUkrainianLabels(){
    const style = map.getStyle(); if (!style || !style.layers) return;
    const ukExpr = ['coalesce',['get','name_uk'],['get','name:uk'],['get','name_ua'],['get','name:ua'],['get','name_local'],['get','name']];
    style.layers.forEach(l=>{
      if (l.type === 'symbol') {
        const has = map.getLayoutProperty(l.id, 'text-field') !== undefined;
        if (has) { try { map.setLayoutProperty(l.id, 'text-field', ukExpr); } catch(_){ } }
      }
    });
  }

  document.getElementById('statMode').textContent = PROFILE;
  const $title = document.getElementById('routeTitle');
  const $dist = document.getElementById('statDistance');
  const $eta = document.getElementById('statEta');
  const $toast = document.getElementById('toast');
  const $notice = document.getElementById('notice');
  const $recenter = document.getElementById('btnRecenter');
  const $fab = document.getElementById('fab');
  const $fabToggle = document.getElementById('fabToggle');
  const $fabMenu = document.getElementById('fabMenu');
  const $keepAwakeBtn = document.getElementById('btnKeepAwake');
  const $keepAwakeFab = document.getElementById('fabKeepAwake');
  const $speedBadge = document.getElementById('speedBadge');
  const $turnBadge = document.getElementById('turnBadge');
  const $turnArrow = $turnBadge ? $turnBadge.querySelector('#turnArrow') : null;
  const $turnText  = $turnBadge ? $turnBadge.querySelector('#turnText') : null;
  const $turnDist  = $turnBadge ? $turnBadge.querySelector('#turnDist') : null;
  const $btnEtaMode = document.getElementById('btnEtaMode');
  const $btnTraffic = document.getElementById('btnTraffic');

  // —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –±–µ–π–¥–∂–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ
  const SPEED_POS_KEY = 'NAV_SPEED_BADGE_POS';
  (function initSpeedBadgeDrag(){
    const el = $speedBadge; if (!el) return;
    // –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó
    try{
      const raw = localStorage.getItem(SPEED_POS_KEY);
      if (raw){
        const p = JSON.parse(raw);
        if (Number.isFinite(p.left) && Number.isFinite(p.top)){
          el.style.left = p.left + 'px'; el.style.top = p.top + 'px';
          el.style.right = 'auto'; el.style.bottom = 'auto';
        }
      }
    }catch(_){ }
    let dragging = null;
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    el.addEventListener('pointerdown', (e)=>{
      try{ el.setPointerCapture(e.pointerId); }catch(_){ }
      // –Ø–∫—â–æ –µ–ª–µ–º–µ–Ω—Ç —â–µ –º–∞—î right/bottom ‚Äî –∫–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ left/top
      const rect = el.getBoundingClientRect();
      if (el.style.left === '' && el.style.top === ''){
        el.style.left = rect.left + 'px'; el.style.top = rect.top + 'px';
        el.style.right = 'auto'; el.style.bottom = 'auto';
      }
      dragging = { x:e.clientX, y:e.clientY, left: parseFloat(el.style.left)||0, top: parseFloat(el.style.top)||0 };
    });
    window.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - dragging.x; const dy = e.clientY - dragging.y;
      const w = el.offsetWidth, h = el.offsetHeight;
      const vw = window.innerWidth, vh = window.innerHeight;
      const nl = clamp(dragging.left + dx, 6, vw - w - 6);
      const nt = clamp(dragging.top + dy, 6 + 64, vh - h - 6); // –Ω–µ –∑–∞–ª–∞–∑–∏—Ç–∏ –ø—ñ–¥ —Ç–æ–ø–±–∞—Ä
      el.style.left = nl + 'px'; el.style.top = nt + 'px';
      el.style.right = 'auto'; el.style.bottom = 'auto';
    });
    window.addEventListener('pointerup', ()=>{
      if (!dragging) return; dragging = null;
      try{
        const left = parseFloat(el.style.left)||0; const top = parseFloat(el.style.top)||0;
        localStorage.setItem(SPEED_POS_KEY, JSON.stringify({left, top}));
      }catch(_){ }
    });
  })();

  // —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è —è—Ä–ª–∏—á–∫–∞ –º–∞–Ω–µ–≤—Ä—É
  const TURN_POS_KEY = 'NAV_TURN_BADGE_POS';
  (function initTurnBadgeDrag(){
    const el = $turnBadge; if (!el) return;
    try{
      const raw = localStorage.getItem(TURN_POS_KEY);
      if (raw){
        const p = JSON.parse(raw);
        if (Number.isFinite(p.left) && Number.isFinite(p.top)){
          el.style.left = p.left + 'px'; el.style.top = p.top + 'px';
          el.style.right = 'auto'; el.style.bottom = 'auto';
        }
      }
    }catch(_){ }
    let dragging = null;
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    el.addEventListener('pointerdown', (e)=>{
      try{ el.setPointerCapture(e.pointerId); }catch(_){ }
      const rect = el.getBoundingClientRect();
      if (el.style.left === '' && el.style.top === ''){
        el.style.left = rect.left + 'px'; el.style.top = rect.top + 'px';
        el.style.right = 'auto'; el.style.bottom = 'auto';
      }
      dragging = { x:e.clientX, y:e.clientY, left: parseFloat(el.style.left)||0, top: parseFloat(el.style.top)||0 };
    });
    window.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - dragging.x; const dy = e.clientY - dragging.y;
      const w = el.offsetWidth, h = el.offsetHeight;
      const vw = window.innerWidth, vh = window.innerHeight;
      const nl = clamp(dragging.left + dx, 6, vw - w - 6);
      const nt = clamp(dragging.top + dy, 6 + 64, vh - h - 6);
      el.style.left = nl + 'px'; el.style.top = nt + 'px';
      el.style.right = 'auto'; el.style.bottom = 'auto';
    });
    window.addEventListener('pointerup', ()=>{
      if (!dragging) return; dragging = null;
      try{
        const left = parseFloat(el.style.left)||0; const top = parseFloat(el.style.top)||0;
        localStorage.setItem(TURN_POS_KEY, JSON.stringify({left, top}));
      }catch(_){ }
    });
  })();

  let routeGeoJSON = null;
  let manualSegments = [];
  let steps = [];
  let routeLengthKm = 0;
  let totalDistance = 0;
  let totalDuration = 0;
  let watchId = null;
  let userMarker = null;
  let lastUserPos = null;
  let firstGPSLock = false;

  let filteredPos = null;
  let filteredHeading = null;
  let lastStableHeading = null; // –∫—É—Ä—Å, —è–∫–∏–π –ø–µ—Ä–µ–¥–∞—î–º–æ –≤ –∫–∞–º–µ—Ä—É

  let lastTs = null;
  let lastSpeedPos = null;
  let speedMps = 0;
  const SPEED_ALPHA = 0.35; // —à–≤–∏–¥—à–µ –ø—ñ–¥–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
  // –î–æ–∑–≤–æ–ª—è—î–º–æ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ >90 –∫–º/–≥–æ–¥, –∞–ª–µ –≤—ñ–¥—Å—ñ–∫–∞—î–º–æ —è–≤–Ω—ñ –≤–∏–∫–∏–¥–∏
  const MAX_SPEED_MPS = 220/3.6; // ~220 –∫–º/–≥–æ–¥
  
  // –Ü—Å—Ç–æ—Ä—ñ—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è (–¥–ª—è ETA)
  let speedHistory = [];
  const SPEED_HISTORY_MAX = 60; // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ 60 –≤–∏–º—ñ—Ä—ñ–≤ (~1 —Ö–≤–∏–ª–∏–Ω–∞ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ —Ä–∞–∑ –Ω–∞ —Å–µ–∫—É–Ω–¥—É)

  let snapFeatures = [];
  let markerHeading = null; // –∑–≥–ª–∞–¥–∂–µ–Ω–∏–π –∫—É—Ä—Å –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó —Å—Ç—Ä—ñ–ª–∫–∏
  window.__etaSmoothed = null;

  let uaVoice = null;
  function pickUkrainianVoice() {
    const voices = window.speechSynthesis?.getVoices?.() || [];
    const ua = voices.filter(v => (v.lang || '').toLowerCase().startsWith('uk'));
    uaVoice = ua.find(v => /google|microsoft|apple/i.test(v.name)) || ua[0] || null;
  }
  if ('speechSynthesis' in window) {
    pickUkrainianVoice(); window.speechSynthesis.onvoiceschanged = pickUkrainianVoice;
  }
  let __lastSpeakAt = 0;
  function speak(text){
    try{
      if (!text) return;
      const now = Date.now();
      if (now - __lastSpeakAt < SPEAK_MIN_GAP_MS) return; // –∞–Ω—Ç–∏-–¥—É–±–ª—ñ–∫–∞—Ç
      if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text); u.lang = 'uk-UA';
      if (uaVoice) u.voice = uaVoice; window.speechSynthesis.speak(u);
      __lastSpeakAt = now;
    }catch(e){}
  }

  function showToast(msg){ $toast.textContent = msg; $toast.style.display='block'; setTimeout(()=>{$toast.style.display='none'}, 1300); }
  function metersToKM(m){ return (m/1000).toFixed(1); }
  function secondsToETA(s){ const dt = new Date(Date.now() + s*1000); const hh=String(dt.getHours()).padStart(2,'0'); const mm=String(dt.getMinutes()).padStart(2,'0'); return `${hh}:${mm}`; }

  async function loadRouteData(){
    let json = null;
    if (SRCZ) {
      try {
        const decompressed = LZString.decompressFromEncodedURIComponent(SRCZ);
        if (decompressed) json = JSON.parse(decompressed);
      } catch(e){ console.warn('srcz decompress error:', e); }
    }
    if (!json && SRC_B64){
      try { json = JSON.parse(b64decodeUtf8(SRC_B64)); }
      catch(e){ console.warn('src base64 parse error:', e); }
    }
    if (!json) throw new Error('–ù–µ –ø–µ—Ä–µ–¥–∞–Ω–æ –º–∞—Ä—à—Ä—É—Ç. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π ?srcz=... –∞–±–æ ?src=...');
    const segs = Array.isArray(json.manualSegments) ? json.manualSegments : [];
    const cleanedSegs = segs.map(arr => (Array.isArray(arr)?arr:[]).filter(p=>Array.isArray(p)&&p.length>=2&&isFinite(p[0])&&isFinite(p[1])));
    return { name: json.name || '–ú–∞—Ä—à—Ä—É—Ç', points: json.points, manualSegments: cleanedSegs };
  }

  function addRouteToMap(){
    if (!routeGeoJSON) return;
    if (map.getSource('route')){
      map.getSource('route').setData(routeGeoJSON);
    } else {
      map.addSource('route', { type:'geojson', data: routeGeoJSON });
      map.addLayer({ id:'route-line', type:'line', source:'route',
        paint:{ 'line-width':6, 'line-color':'#1d4ed8' } });
    }
    const bbox = turf.bbox(routeGeoJSON);
    map.fitBounds(bbox, { padding:{top:80, right:20, bottom:20, left:20}, duration: 500 });
    /* –≤–∏–¥–∞–ª–µ–Ω–æ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –∫–∞–º–µ—Ä —à–≤–∏–¥–∫–æ—Å—Ç—ñ */
  }

  function addManualToMap(){
    const fc = {
      type:'FeatureCollection',
      features:(manualSegments||[]).map(seg => ({ type:'Feature', geometry:{ type:'LineString', coordinates: seg }, properties:{} }))
    };
    if (map.getSource('manual')){
      map.getSource('manual').setData(fc);
    } else {
      map.addSource('manual', { type:'geojson', data: fc });
      map.addLayer({
        id:'manual-line', type:'line', source:'manual',
        paint:{
          'line-width':4,
          'line-color':'#ef4444',
          'line-dasharray':[2,2]
        }
      });
    }
  }

  function rebuildSnapFeatures(){
    snapFeatures = [];
    if (routeGeoJSON) snapFeatures.push({ type:'Feature', geometry: routeGeoJSON.geometry, properties:{_kind:'route'} });
    (manualSegments||[]).forEach(seg => snapFeatures.push({ type:'Feature', geometry:{type:'LineString', coordinates: seg}, properties:{_kind:'manual'} }));
    /* –≤–∏–¥–∞–ª–µ–Ω–æ –ø—ñ–¥—Ç—Ä–∏–º–∫—É –∫–∞–º–µ—Ä —à–≤–∏–¥–∫–æ—Å—Ç—ñ */
  }

  async function fetchDirections(points){
    const coords = points.map(p => p.join(',')).join(';');
    const url = `https://api.mapbox.com/directions/v5/mapbox/${PROFILE}/${coords}?alternatives=false&geometries=geojson&overview=full&steps=true&language=uk&voice_units=metric&access_token=${MAPBOX_TOKEN}`;
    const res = await fetch(url);
    if (!res.ok){
      const text = await res.text().catch(()=> '');
      console.error('Directions API error', res.status, text);
      throw new Error(`Directions API error (${res.status})`);
    }
    const json = await res.json();
    if (!json.routes || !json.routes[0]) throw new Error('–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –ø–æ–±—É–¥–æ–≤–∞–Ω–æ');
    const r = json.routes[0];
    routeGeoJSON = { type:'Feature', geometry:r.geometry, properties:{} };
    totalDistance = r.distance; totalDuration = r.duration;
    $dist.textContent = `${metersToKM(totalDistance)} –∫–º`;
    $eta.textContent = `ETA ${secondsToETA(totalDuration)}`;

    const rawSteps = r.legs.flatMap(l=>l.steps);
    routeLengthKm = turf.length(routeGeoJSON, {units:'kilometers'});
    steps = rawSteps.map((s) => {
      const manCoord = (s.maneuver && Array.isArray(s.maneuver.location)) ? s.maneuver.location : s.geometry.coordinates.at(-1);
      const snap = turf.nearestPointOnLine(routeGeoJSON, manCoord, {units:'kilometers'});
      const locKm = (snap.properties && typeof snap.properties.location === 'number') ? snap.properties.location : 0;
      s._manCoord = manCoord; s._locKm = locKm; return s;
    }).sort((a,b)=>a._locKm - b._locKm);

    return routeGeoJSON;
  }

  function clampWaypoints(points, maxWaypoints = 25){
    const clean = (points || []).filter(p =>
      Array.isArray(p) && p.length >= 2 &&
      Number.isFinite(p[0]) && Number.isFinite(p[1]) &&
      Math.abs(p[0]) <= 180 && Math.abs(p[1]) <= 90
    );
    if (clean.length <= maxWaypoints) return clean;
    const out = [clean[0]];
    const step = (clean.length - 1) / (maxWaypoints - 1);
    for (let i = 1; i < maxWaypoints - 1; i++){
      out.push(clean[Math.round(i * step)]);
    }
    out.push(clean[clean.length - 1]);
    return out;
  }

  function ensureUserMarker(lng, lat){
    if (!userMarker){
      // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –ø—Ä–æ—Å—Ç–∏–π –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π –∫—Ä—É–∂–æ–∫ –ø–æ–∑–∏—Ü—ñ—ó
      const el = document.createElement('div');
      el.style.width = '24px';
      el.style.height = '24px';
      el.style.borderRadius = '50%';
  // –ë—ñ–ª—å—à–µ –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–æ–≥–æ, –º–µ–Ω—à–µ –±—ñ–ª–æ–≥–æ: –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞ –∑–∞–ª–∏–≤–∫–∞ + —Ç–æ–Ω–∫–∏–π –±—ñ–ª–∏–π –∫–∞–Ω—Ç
  el.style.background = '#f59e0b'; /* orange-500 */
  el.style.border = '2px solid #ffffff';
  el.style.boxShadow = '0 0 0 4px rgba(245,158,11,.30), 0 2px 8px rgba(0,0,0,.25)';
      el.style.pointerEvents = 'none';
      // –í–∏—Ä—ñ–≤–Ω—é—î–º–æ —è–∫ —ñ–∫–æ–Ω–∫—É –ø–æ —Ü–µ–Ω—Ç—Ä—É
      userMarker = new mapboxgl.Marker({
        element: el,
        anchor: 'center',
        rotationAlignment: 'viewport', // –æ–±–µ—Ä—Ç–∞—Ç–∏ –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è –∫–∞—Ä—Ç–∏
        pitchAlignment: 'map'
      }).setLngLat([lng, lat]).addTo(map);
    } else {
      userMarker.setLngLat([lng, lat]);
    }
  }

  // –û–±–µ—Ä—Ç–∞–Ω–Ω—è –º–∞—Ä–∫–µ—Ä–∞ –∑–∞ –∫—É—Ä—Å–æ–º —Ä—É—Ö—É (—É –≥—Ä–∞–¥—É—Å–∞—Ö 0..360)
  function setUserMarkerHeading(deg){
    if (!userMarker) return;
    if (deg==null || Number.isNaN(deg)) return;
    try { userMarker.setRotation(((deg + MARKER_ROT_OFFSET) % 360 + 360) % 360); } catch(_){ /* Mapbox GL v2 –ø—ñ–¥—Ç—Ä–∏–º—É—î setRotation */ }
  }

  // –û–±—á–∏—Å–ª–∏—Ç–∏ –Ω–∞–ø—Ä—è–º–æ–∫ –ª—ñ–Ω—ñ—ó (–º–∞—Ä—à—Ä—É—Ç—É/—Ä—É—á–Ω–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞) —É —Ç–æ—á—Ü—ñ –ø–æ–±–ª–∏–∑—É LL
  function bearingAlongLineAtPoint(lineFeature, ll){
    try{
      const snap = turf.nearestPointOnLine(lineFeature, ll, {units:'meters'});
      const idx = Math.max(0, Math.min((snap.properties?.index ?? 0), lineFeature.geometry.coordinates.length - 2));
      const a = lineFeature.geometry.coordinates[idx];
      const b = lineFeature.geometry.coordinates[idx+1];
      return (turf.bearing(turf.point(a), turf.point(b)) + 360) % 360;
    }catch(_){ return null; }
  }

  // –ù–∞–ø—Ä—è–º–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É (routeGeoJSON) —É —Ç–æ—á—Ü—ñ –ø–æ–±–ª–∏–∑—É LL, –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º –≤—ñ–¥—Å—Ç–∞–Ω—ñ –≤–∑–¥–æ–≤–∂ –ª—ñ–Ω—ñ—ó (–±—ñ–ª—å—à —Å—Ç–∞–±—ñ–ª—å–Ω–∏–π –Ω–∞–ø—Ä—è–º–æ–∫)
  function bearingAlongRouteAtLL(ll){
    if (!routeGeoJSON) return null;
    try{
      const snap = turf.nearestPointOnLine(routeGeoJSON, ll, {units:'kilometers'});
      const locKm = snap?.properties?.location;
      if (typeof locKm !== 'number' || !Number.isFinite(locKm)) return null;
      const delta = Math.max(0.01, Math.min(0.05, Math.max(speedMps*0.02, 0.02))); // 10‚Äì50 –º –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —à–≤–∏–¥–∫–æ—Å—Ç—ñ
      const p1 = turf.along(routeGeoJSON, Math.max(0, locKm - delta));
      const p2 = turf.along(routeGeoJSON, Math.min(routeLengthKm, locKm + delta));
      return (turf.bearing(p1, p2) + 360) % 360;
    }catch(_){ return null; }
  }

  function computeHeading(prev, curr){
    if (!prev) return null;
    const bearing = turf.bearing(turf.point(prev), turf.point(curr));
    return (bearing+360)%360;
  }

  function normDeg(a){ a%=360; if (a<0) a+=360; return a; }
  function angleDelta(a,b){
    if (a==null||b==null) return 0;
    let d = normDeg(a) - normDeg(b);
    while (d>180) d-=360; while (d<-180) d+=360; return d;
  }
  function lerpAngle(from, to, alpha){
    if (from==null) return to;
    const d = angleDelta(to, from);
    return normDeg(from + d * alpha);
  }

  function updateCamera(centerLL, bearingDeg){
    if (!centerLL) return;
    const opts = {
      center: centerLL, duration: CAMERA_DURATION, essential: true,
      bearing: (bearingDeg!=null && !Number.isNaN(bearingDeg)) ? bearingDeg : map.getBearing(),
      pitch: NAV_PITCH_DEG, offset: [0, NAV_OFFSET_PX]
    };
    // –ù–µ –∑–º—ñ–Ω—é—î–º–æ –∑—É–º —Ç—É—Ç ‚Äî –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–æ–∂–µ –∫–µ—Ä—É–≤–∞—Ç–∏ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ +/-

      // –†–∞–∑–æ–≤–æ –≤–∏—Å—Ç–∞–≤–ª—è—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –∑—É–º –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó
      if (map.getZoom() < NAV_MIN_ZOOM) map.jumpTo({ zoom: NAV_MIN_ZOOM });
    
    // –ü–µ—Ä—à–µ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è ‚Äî –º–∏—Ç—Ç—î–≤–æ, –¥–∞–ª—ñ ‚Äî –ø–ª–∞–≤–Ω–æ
    if (!firstGPSLock) {
      map.jumpTo({ center: centerLL, bearing: opts.bearing, pitch: opts.pitch });
      firstGPSLock = true;
    } else {
      map.easeTo(opts);
    }
  }

  // –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —è—Ä–ª–∏—á–∫–∞ –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ –º–∞–Ω–µ–≤—Ä—É
  function descriptorForStep(step){
    const man = step?.maneuver || {}; const mod = String(man.modifier||'').toLowerCase();
    const type = String(man.type||'').toLowerCase();
    if (type === 'arrive') return { mode:'text', text:'üèÅ' };
    if (type.includes('roundabout')) return { mode:'text', text:'‚ü≥' };
    if (type.includes('uturn') || mod.includes('uturn')) return { mode:'arrow', angle:180 };
    if (type === 'merge' && mod.includes('right')) return { mode:'arrow', angle: 45 };
    if (type === 'merge' && mod.includes('left'))  return { mode:'arrow', angle:-45 };
    if (mod === 'right')       return { mode:'arrow', angle: 90 };
    if (mod === 'left')        return { mode:'arrow', angle:-90 };
    if (mod === 'slight right')return { mode:'arrow', angle: 45 };
    if (mod === 'slight left') return { mode:'arrow', angle:-45 };
    if (mod === 'sharp right') return { mode:'arrow', angle:135 };
    if (mod === 'sharp left')  return { mode:'arrow', angle:-135 };
    // straight / continue / fallback
    return { mode:'arrow', angle:0 };
  }
  function updateTurnBadge(desc){
    if (!$turnBadge || (!$turnArrow && !$turnText)) return;
    if (!desc){
      if ($turnArrow) $turnArrow.style.display = 'none';
      if ($turnText)  $turnText.style.display  = 'none';
      return;
    }
    if (desc.mode === 'text'){
      if ($turnArrow) $turnArrow.style.display = 'none';
      if ($turnText){ $turnText.style.display = 'block'; $turnText.textContent = desc.text || ''; }
    } else { // arrow
      if ($turnText)  $turnText.style.display  = 'none';
      if ($turnArrow){
        $turnArrow.style.display = 'block';
        $turnArrow.style.transform = `rotate(${desc.angle||0}deg)`;
      }
    }
  }

  function formatDistanceShort(m){
    if (!Number.isFinite(m) || m < 0) return '‚Äî';
    if (m < 1000) return `${Math.round(m)} –º`;
    const km = m / 1000;
    return `${km.toFixed(km < 10 ? 1 : 0)} –∫–º`;
  }
  /* –≤–∏–¥–∞–ª–µ–Ω–æ —Ñ—É–Ω–∫—Ü—ñ—ó —Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –∫–∞–º–µ—Ä —à–≤–∏–¥–∫–æ—Å—Ç—ñ */
  function updateTurnDistance(m){
    if (!$turnDist) return;
    if (!Number.isFinite(m)) { $turnDist.style.display='none'; return; }
    $turnDist.textContent = formatDistanceShort(m);
    $turnDist.style.display = 'block';
  }

  // –û—Ü—ñ–Ω–∫–∞ –∑–∞—Ç—Ä–∏–º–æ–∫ –Ω–∞ —Å–≤—ñ—Ç–ª–æ—Ñ–æ—Ä–∞—Ö/–º–∞–Ω–µ–≤—Ä–∞—Ö –ø–æ–ø–µ—Ä–µ–¥—É (–ø—Ä–æ—Å—Ç–∏–π –µ–≤—Ä–∏—Å—Ç–∏—á–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥)
  function computeTrafficLightPenalty(userLocKm, remainMeters){
    try{
      if (!Array.isArray(steps) || steps.length === 0) return 0;
      const lookaheadM = Math.min(2000, Math.max(500, remainMeters || 0));
      const toKm = lookaheadM / 1000;
      let penalty = 0;
      for (const s of steps){
        const loc = s._locKm ?? 0; if (loc <= userLocKm) continue; if (loc - userLocKm > toKm) break;
        const t = String(s.maneuver?.type||'').toLowerCase();
        const m = String(s.maneuver?.modifier||'').toLowerCase();
        if (t.includes('roundabout')) { penalty += 12; continue; }
        if (t === 'merge') { penalty += 8; continue; }
        if (t === 'arrive') continue;
        if (t === 'turn' || t === 'end of road' || t === 'fork' || t === 'exit'){
          penalty += 18;
          continue;
        }
        // –¥–µ—è–∫—ñ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó —Ç–∏–ø—É 'new name' –∞–±–æ 'continue' –Ω–µ –¥–æ–¥–∞—î–º–æ
      }
      // –û–±–º–µ–∂–µ–Ω–Ω—è: –Ω–µ –±—ñ–ª—å—à–µ 45 —Å –Ω–∞ –∫–æ–∂–µ–Ω –∫–º –ø–æ–ø–µ—Ä–µ–¥—É
      const cap = (lookaheadM/1000) * 45;
      return Math.min(penalty, cap);
    }catch(_){ return 0; }
  }

  let spoken = { idx: -1, early: false, now: false };
  function resetSpokenFor(idx){ spoken = { idx, early:false, now:false }; }

  function isArrivalStep(step){
    return (step && step.maneuver && String(step.maneuver.type||'').toLowerCase() === 'arrive');
  }
  function isFinalArrival(step){
    if (!step) return false;
    const idx = step._index ?? steps.indexOf(step);
    return isArrivalStep(step) && idx === steps.length - 1;
  }

  function sanitizeInstruction(text){
    return String(text||'')
      .replace(/Turn right/i, '–ü–æ–≤–µ—Ä–Ω—ñ—Ç—å –ø—Ä–∞–≤–æ—Ä—É—á')
      .replace(/Turn left/i, '–ü–æ–≤–µ—Ä–Ω—ñ—Ç—å –ª—ñ–≤–æ—Ä—É—á')
      .replace(/Continue/i, '–†—É—Ö–∞–π—Ç–µ—Å—å –ø—Ä—è–º–æ')
      .replace(/At the roundabout/i, '–ù–∞ –∫–æ–ª—ñ')
      .replace(/Take the exit/i, '–ó º—ó–∂–¥–∂–∞–π—Ç–µ –Ω–∞ –≤–∏—ó–∑–¥')
      .trim();
  }

  function stepToSpeech(step, mode='soon', overrideMeters=null){
    const man = step.maneuver || {};
    const arr = isArrivalStep(step);
    if (arr && !isFinalArrival(step)) return '';
    let text = sanitizeInstruction(man.instruction || '');
    if (arr && isFinalArrival(step)){
      if (mode === 'now') return '–í–∏ –ø—Ä–∏–±—É–ª–∏ –¥–æ –º—ñ—Å—Ü—è –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è.';
      const d = Math.round(overrideMeters ?? (step.distance||0));
      const add = d < 1000 ? `${d} –º–µ—Ç—Ä—ñ–≤` : `${(d/1000).toFixed(1)} –∫—ñ–ª–æ–º–µ—Ç—Ä–∞`;
      return `–§—ñ–Ω—ñ—à –∑–∞ ${add}.`;
    }
    if (mode === 'now') return '–ó–∞—Ä–∞–∑: ' + text.replace(/\. –ó–∞ .+$/,'');
    const d = Math.round(overrideMeters ?? (step.distance||0));
    const add = d < 1000 ? `${d} –º` : `${(d/1000).toFixed(1)} –∫–º`;
    if (!/–º|km|–∫–º/.test(text)) return `${text}. –ó–∞ ${add}`;
    return text;
  }

  // ===== 1D —Ç—Ä–µ–∫–µ—Ä –≤–∑–¥–æ–≤–∂ –º–∞—Ä—à—Ä—É—Ç—É (locKm) =====
  const routeTracker = { posKm: null, velKps: 0, lastTs: null };
  function clampKm(km){ return Math.max(0, Math.min(routeLengthKm || 0, km)); }
  function rtInit(locKm, ts){
    routeTracker.posKm = clampKm(locKm);
    routeTracker.velKps = 0;
    routeTracker.lastTs = ts;
    if (!window.__anim) window.__anim = { running:false, currKm: routeTracker.posKm, last: null };
  }
  function rtUpdate(locKm, ts){
    if (locKm==null || !Number.isFinite(locKm)) return;
    if (routeTracker.posKm==null) { rtInit(locKm, ts); return; }
    const dt = Math.max(0.05, ((typeof ts==='number'?ts:Date.now()) - (routeTracker.lastTs||ts))/1000);
    const meas = clampKm(locKm);
    const r = meas - routeTracker.posKm;          // —ñ–Ω–Ω–æ–≤–∞—Ü—ñ—è
    // alpha-beta: –ø—Ä–æ–≥–Ω–æ–∑ + –∫–æ—Ä–µ–∫—Ü—ñ—è
    routeTracker.posKm = routeTracker.posKm + routeTracker.velKps * dt + TRACK_ALPHA * r;
    routeTracker.velKps = routeTracker.velKps + (TRACK_BETA * r) / dt;
    // –æ–±–º–µ–∂–µ–Ω–Ω—è
    if (!Number.isFinite(routeTracker.velKps)) routeTracker.velKps = 0;
    routeTracker.velKps = Math.max(0, Math.min(MAX_KPS, routeTracker.velKps));
    routeTracker.posKm = clampKm(routeTracker.posKm);
    routeTracker.lastTs = (typeof ts==='number'?ts:Date.now());
  }

  // –ê–Ω—ñ–º–∞—Ü—ñ–π–Ω–∏–π —Ü–∏–∫–ª, —â–æ –ø–ª–∞–≤–Ω–æ –≤–µ–¥–µ –º–∞—Ä–∫–µ—Ä/–∫–∞–º–µ—Ä—É –¥–æ rt.posKm
  function ensureAnimLoop(){
    if (!window.__anim) window.__anim = { running:false, currKm:null, last:null };
    const A = window.__anim; if (A.running) return;
    A.running = true; window.__animLoopActive = true;
    const step = (t)=>{
      const now = t || performance.now();
      const dt = A.last ? Math.max(0, (now - A.last)/1000) : 0; A.last = now;
      const targetKm = (routeTracker.posKm!=null) ? routeTracker.posKm : A.currKm;
      if (A.currKm==null) A.currKm = targetKm;
      // –°–∫—ñ–ª—å–∫–∏ –º–æ–∂–µ–º–æ –ø—Ä–æ–π—Ç–∏ –∑–∞ –∫–∞–¥—Ä: –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –æ—Ü—ñ–Ω–µ–Ω–æ—ó —à–≤–∏–¥–∫–æ—Å—Ç—ñ, –∞–ª–µ –Ω–µ –º–µ–Ω—à–µ –º–∞–ª–æ–≥–æ –∫—Ä–æ–∫—É
      const maxStep = Math.max(0.001, (routeTracker.velKps||0) * dt * 1.6); // ~–Ω–∞–∑–¥–æ–≥–∞–Ω—è—î–º–æ, –∞–ª–µ –±–µ–∑ —Å—Ç—Ä–∏–±–∫—ñ–≤
      const diff = (targetKm - A.currKm) || 0;
      const move = Math.sign(diff) * Math.min(Math.abs(diff), maxStep);
      A.currKm = clampKm((A.currKm||0) + move);
      // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä—É
      if (routeGeoJSON && Number.isFinite(A.currKm)){
        try{
          const p = turf.along(routeGeoJSON, A.currKm);
          const ll = p.geometry.coordinates;
          ensureUserMarker(ll[0], ll[1]);
          // –î–ª—è –∫–∞–º–µ—Ä–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–∞–±—ñ–ª—å–Ω–∏–π –∫—É—Ä—Å –∑ onPosition, —Ü–µ–Ω—Ç—Ä ‚Äî –∞–Ω—ñ–º–æ–≤–∞–Ω–∏–π
          const bearingForCamera = lastStableHeading ?? filteredHeading;
          if (followHard || autoCenter) updateCamera(ll, bearingForCamera);
        }catch(_){ }
      }
      requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  function nearestOnAnyLine(ll){
    if (!snapFeatures.length) return null;
    let best=null, min=Infinity, which='route', idx=-1;
    snapFeatures.forEach((feat,i)=>{
      const pt = turf.nearestPointOnLine(feat, ll, {units:'meters'});
      const d = pt.properties?.dist ?? pt.properties?.distance ?? Infinity;
      if (d < min){ min = d; best = pt; which = feat.properties?._kind || 'route'; idx=i; }
    });
    if (!best) return null;
    return { coord: best.geometry.coordinates, dist: min, which, idx };
  }

  let followHard = true;
  let autoCenter = true;
  
  // –¢–∏–º—á–∞—Å–æ–≤–µ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –ø—Ä–∏ —Å–≤–∞–π–ø—ñ, –∞–ª–µ –∞–≤—Ç–æ–ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è —á–µ—Ä–µ–∑ 10 —Å–µ–∫
  let autoCenterTimeoutId = null;
  
  function setFollowUI(){
    const $recenter = document.getElementById('btnRecenter');
    if (followHard){ 
      $recenter.textContent = 'üîí'; 
      $recenter.title = '–°—Ç–µ–∂–µ–Ω–Ω—è: —É–≤—ñ–º–∫–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –¥–æ–∑–≤–æ–ª–∏—Ç–∏ –≤—ñ–ª—å–Ω–∏–π –ø–µ—Ä–µ–≥–ª—è–¥ –∫–∞—Ä—Ç–∏';
      $recenter.style.background = '#10b981'; // green
      $recenter.style.color = 'white';
    }
    else { 
      $recenter.textContent = 'üìç'; 
      $recenter.title = '–°—Ç–µ–∂–µ–Ω–Ω—è: –≤–∏–º–∫–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –∑–Ω–æ–≤—É —É–≤—ñ–º–∫–Ω—É—Ç–∏';
      $recenter.style.background = '#ef4444'; // red
      $recenter.style.color = 'white';
    }
  }
  setFollowUI();
  
  // –ü—Ä–∏ —Ä—É—á–Ω–æ–º—É –∫–µ—Ä—É–≤–∞–Ω–Ω—ñ –∫–∞—Ä—Ç–æ—é ‚Äî —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∏–∫–∞—î–º–æ —Å—Ç–µ–∂–µ–Ω–Ω—è
  function onUserMapInteraction(){
    if (!followHard) {
      autoCenter = false;
      // –°–∫–∏–¥–∞—î–º–æ —Ç–∞–π–º–µ—Ä –∞–≤—Ç–æ–ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è
      if (autoCenterTimeoutId) clearTimeout(autoCenterTimeoutId);
    } else {
      // –Ø–∫—â–æ followHard —É–≤—ñ–º–∫–Ω–µ–Ω–æ ‚Äî –ø—Ä–æ—Å—Ç–æ —ñ–≥–Ω–æ—Ä—É—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ —Ç–æ—Ä–∫–∞–Ω–Ω—è
      // –ö–∞—Ä—Ç–∞ –±—É–¥–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏—Å—å –¥–æ —Å–ª—ñ–¥–∫—É–≤–∞–Ω–Ω—è –∑–∞ GPS
    }
  }
  
  map.on('dragstart',   onUserMapInteraction);
  map.on('rotatestart', onUserMapInteraction);
  map.on('pitchstart',  onUserMapInteraction);
  
  document.getElementById('btnRecenter').onclick = ()=>{
    followHard = !followHard; autoCenter = followHard; setFollowUI();
    if (followHard && lastUserPos) updateCamera(lastUserPos, (lastStableHeading ?? filteredHeading));
    // –°–∫–∏–¥–∞—î–º–æ —Ç–∞–π–º–µ—Ä –ø—Ä–∏ —Ä—É—á–Ω–æ–º—É –≤–∏–º–∫–Ω–µ–Ω–Ω—ñ
    if (autoCenterTimeoutId) clearTimeout(autoCenterTimeoutId);
  };

  function getNextStepByLocation(userLocKm){
    if (!steps || steps.length === 0) return null;
    let sel = null;
    for (let i = 0; i < steps.length; i++){
      const s = steps[i];
      if (s._locKm > userLocKm){
        if (isArrivalStep(s) && i !== steps.length - 1) continue;
        s._index = i;
        s._metersToManeuver = Math.max(0, (s._locKm - userLocKm) * 1000);
        s._remainMeters = Math.max(0, (routeLengthKm - userLocKm) * 1000);
        sel = s; break;
      }
    }
    if (sel && isArrivalStep(sel) && sel._index !== steps.length - 1){
      const j = Math.min(steps.length - 1, sel._index + 1);
      const t = steps[j];
      t._index = j;
      t._metersToManeuver = Math.max(0, (t._locKm - userLocKm) * 1000);
      t._remainMeters = Math.max(0, (routeLengthKm - userLocKm) * 1000);
      return t;
    }
    return sel;
  }

  function onPosition(pos){
    if (Number.isFinite(pos.coords.accuracy) && pos.coords.accuracy > GPS_ACCURACY_MAX) return;
    const raw = [pos.coords.longitude, pos.coords.latitude];

    let onLine = raw; let snappedKind = null;
    const snap = nearestOnAnyLine(raw);
    if (snap && snap.dist <= SNAP_MAX_METERS){
      onLine = snap.coord; snappedKind = snap.which;
    }
    // –û–±—á–∏—Å–ª—é—î–º–æ timestamp –æ–¥—Ä–∞–∑—É, —â–æ–± –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –≤ —É—Å—ñ—Ö –≥—ñ–ª–∫–∞—Ö –Ω–∏–∂—á–µ
    const ts = (typeof pos.timestamp === 'number' ? pos.timestamp : Date.now());

    // –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –≤–∑–¥–æ–≤–∂ –º–∞—Ä—à—Ä—É—Ç—É (–±–µ–∑ ¬´–∑—Ä—ñ–∑–∞–Ω–Ω—è –∫—É—Ç—ñ–≤¬ª)
    // –Ø–∫—â–æ –ø—Ä–∏–ª–∏–ø–∞—î–º–æ –¥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É ‚Äî –∑–≥–ª–∞–¥–∂—É—î–º–æ –Ω–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏, –∞ –ø–æ–ª–æ–∂–µ–Ω–Ω—è –≤–∑–¥–æ–≤–∂ –ª—ñ–Ω—ñ—ó (–∫—ñ–ª–æ–º–µ—Ç—Ä–∏)
    if (routeGeoJSON && snappedKind === 'route'){
      try{
        const snapKm = turf.nearestPointOnLine(routeGeoJSON, onLine, {units:'kilometers'});
        const locKm = (snapKm.properties && typeof snapKm.properties.location === 'number') ? snapKm.properties.location : 0;
        // –û–Ω–æ–≤–ª—é—î–º–æ —Ç—Ä–µ–∫–µ—Ä —É–∑–¥–æ–≤–∂ –º–∞—Ä—à—Ä—É—Ç—É
        rtUpdate(locKm, ts);
        const p = turf.along(routeGeoJSON, routeTracker.posKm ?? locKm);
        filteredPos = p.geometry.coordinates;
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ –ø–ª–∞–≤–Ω—É –∞–Ω—ñ–º–∞—Ü—ñ—é, —è–∫—â–æ —â–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞
        ensureAnimLoop();
      }catch(_){ filteredPos = onLine; }
    } else {
      // –Ü–Ω–∞–∫—à–µ ‚Äî –∑–≤–∏—á–∞–π–Ω–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–µ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è
      let routeDirHere = null;
      if (routeGeoJSON) routeDirHere = bearingAlongRouteAtLL(onLine) ?? null;
      const smoothAlphaPos = (routeDirHere != null && filteredHeading != null && Math.abs(angleDelta(routeDirHere, filteredHeading)) > 30)
        ? 0.7 : SMOOTH_ALPHA_POS;
      filteredPos = filteredPos
        ? [ filteredPos[0] + (onLine[0] - filteredPos[0]) * smoothAlphaPos,
            filteredPos[1] + (onLine[1] - filteredPos[1]) * smoothAlphaPos ]
        : onLine;
    }

    const gpsHeading = Number.isFinite(pos.coords.heading) ? pos.coords.heading : null;
    const headingInstant = gpsHeading != null ? gpsHeading : (lastUserPos ? computeHeading(lastUserPos, filteredPos) : null);
    // –í–∏—Ä–∞—Ö—É—î–º–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å/—Ä—É—Ö
    // –û—Ü—ñ–Ω–∫–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ GPS speed, —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω–æ; —ñ–Ω–∞–∫—à–µ ‚Äî —Ä—ñ–∑–Ω–∏—Ü—é –ø–æ–∑–∏—Ü—ñ–π
    if (Number.isFinite(pos.coords.speed)){
      const gpsV = Math.max(0, Math.min(MAX_SPEED_MPS, pos.coords.speed));
      speedMps = (1 - SPEED_ALPHA)*speedMps + SPEED_ALPHA*gpsV;
    } else if (lastSpeedPos && lastTs){
      const dM = turf.distance(turf.point(lastSpeedPos), turf.point(filteredPos), {units:'kilometers'})*1000;
      const dt = Math.max(0.15, (ts - lastTs)/1000);
      const inst = Math.min(dM/dt, MAX_SPEED_MPS);
      speedMps = (1 - SPEED_ALPHA)*speedMps + SPEED_ALPHA*inst;
    }
    // –î–æ–¥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω—É —à–≤–∏–¥–∫—ñ—Å—Ç—å –≤ —ñ—Å—Ç–æ—Ä—ñ—é –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ ETA
    if (speedMps > 0.5) { // –¥–æ–¥–∞—î–º–æ —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Ä—É—Ö–∞—î–º–æ—Å—è
      speedHistory.push(speedMps);
      if (speedHistory.length > SPEED_HISTORY_MAX) speedHistory.shift();
    }
    
    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–ª–∞–≤–∞—é—á–æ–≥–æ –±–µ–π–¥–∂–∞ —à–≤–∏–¥–∫–æ—Å—Ç—ñ (–∫–º/–≥–æ–¥)
    if ($speedBadge){
      const v = Math.round(Math.max(0, speedMps) * 3.6);
      $speedBadge.textContent = String(v);
      if (v > 60){
        $speedBadge.style.background = '#ef4444';
        $speedBadge.style.color = '#fff';
        $speedBadge.style.borderColor = '#b91c1c';
      } else {
        $speedBadge.style.background = '#ffffff';
        $speedBadge.style.color = '#111827';
        $speedBadge.style.borderColor = 'var(--line)';
      }
    }
    const movedEnough = lastSpeedPos
      ? turf.distance(turf.point(lastSpeedPos), turf.point(filteredPos), {units:'kilometers'})*1000 > MIN_MOVE_FOR_HEADING_M
      : false;
    const isMoving = (speedMps > STATIONARY_SPEED_MPS) && movedEnough;

    if (headingInstant != null && isMoving){
      filteredHeading = lerpAngle(filteredHeading, headingInstant, SMOOTH_ALPHA_HD);
      // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞–±—ñ–ª—å–Ω–∏–π –∫—É—Ä—Å –ª–∏—à–µ –∫–æ–ª–∏ —Ä—É—Ö–∞—î–º–æ—Å—è –ø–æ–º—ñ—Ç–Ω–æ
      if (lastStableHeading == null) lastStableHeading = filteredHeading;
      const diff = Math.abs(angleDelta(filteredHeading, lastStableHeading));
      if (diff > BEARING_DEADBAND_DEG) lastStableHeading = filteredHeading;
    }
    lastUserPos = filteredPos;
    lastSpeedPos = filteredPos; lastTs = ts;

  // –Ø–∫—â–æ –ø—Ä–∞—Ü—é—î –∞–Ω—ñ–º–∞—Ü—ñ–π–Ω–∏–π —Ü–∏–∫–ª, —Ä–µ–Ω–¥–µ—Ä –ø–æ–∑–∏—Ü—ñ—ó –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –≤ –Ω—å–æ–º—É
  if (!window.__animLoopActive) ensureUserMarker(filteredPos[0], filteredPos[1]);

    // –û–±—á–∏—Å–ª—é—î–º–æ –Ω–∞–ø—Ä—è–º–æ–∫ –¥–ª—è –º–∞—Ä–∫–µ—Ä–∞: –ø–µ—Ä–µ–≤–∞–≥–∞ –Ω–∞–ø—Ä—è–º—É –º–∞—Ä—à—Ä—É—Ç—É –ø—Ä–∏ –≤–µ–ª–∏–∫–∏—Ö —Ä–æ–∑–±—ñ–∂–Ω–æ—Å—Ç—è—Ö/–Ω–∞ –º–∞–ª–∏—Ö —à–≤–∏–¥–∫–æ—Å—Ç—è—Ö
    const near = nearestOnAnyLine(filteredPos);
    const routeBearing = (near && near.which === 'route') ? (bearingAlongRouteAtLL(filteredPos) ?? null) : null;
    const lineBearing  = (near && near.which !== 'route') ? (bearingAlongLineAtPoint(snapFeatures[near.idx], filteredPos) ?? null) : null;
    const pathBearing  = routeBearing ?? lineBearing;
    let headingForMarker = filteredHeading ?? lastStableHeading ?? pathBearing;
    if (pathBearing != null){
      const dev = Math.abs(angleDelta(headingForMarker ?? pathBearing, pathBearing));
      const preferPath = !isMoving || dev > 30;
      // –Ø–∫—â–æ —Ä–æ–∑–≤–æ—Ä–æ—Ç/—Å–∏–ª—å–Ω–µ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è ‚Äî –∂–æ—Ä—Å—Ç–∫–æ –ø—Ä–∏–≤ º—è–∑—É—î–º–æ—Å—è –¥–æ –Ω–∞–ø—Ä—è–º—É —à–ª—è—Ö—É
      if (dev > 100) headingForMarker = pathBearing;
      if (preferPath) headingForMarker = pathBearing;
    }
    // –ó–≥–ª–∞–¥–∂—É—î–º–æ –æ–∫—Ä–µ–º–æ –≤—ñ–∑—É–∞–ª—å–Ω–∏–π –∫—É—Ä—Å –º–∞—Ä–∫–µ—Ä–∞, —â–æ–± —É–Ω–∏–∫–∞—Ç–∏ "—Å–º–∏–∫–∞–Ω—å"
    markerHeading = lerpAngle(markerHeading, headingForMarker ?? markerHeading, 0.45);
    setUserMarkerHeading(markerHeading ?? headingForMarker);

    // –ö–æ–ª–∏ —Å—Ç–æ—ó–º–æ ‚Äî —Ç—Ä–∏–º–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Å—Ç–∞–±—ñ–ª—å–Ω–∏–π –∫—É—Ä—Å, —â–æ–± –∫–∞–º–µ—Ä–∞ –Ω–µ "—Ç–∞–Ω—Ü—é–≤–∞–ª–∞"
    const bearingForCamera = lastStableHeading ?? filteredHeading;
  if (!window.__animLoopActive && (followHard || autoCenter)) updateCamera(filteredPos, bearingForCamera);

    if (routeGeoJSON){
      const snapKm = turf.nearestPointOnLine(routeGeoJSON, filteredPos, {units:'kilometers'});
      const userLocKm = (snapKm.properties && typeof snapKm.properties.location === 'number') ? snapKm.properties.location : 0;
      const remainRoute = Math.max(0, (routeLengthKm - userLocKm) * 1000);

      /* –≤–∏–¥–∞–ª–µ–Ω–æ –æ–∑–≤—É—á–µ–Ω–Ω—è –∫–∞–º–µ—Ä —à–≤–∏–¥–∫–æ—Å—Ç—ñ */

      if (snappedKind === 'manual'){
        const nearManual = nearestOnAnyLine(filteredPos);
        if (nearManual && nearManual.which === 'manual'){
          const feat = snapFeatures[nearManual.idx];
          const p = turf.nearestPointOnLine(feat, filteredPos, {units:'meters'});
          const tail = turf.lineSlice(p, turf.point(feat.geometry.coordinates.at(-1)), feat);
          const remain = turf.length(tail, {units:'kilometers'})*1000;
          $dist.textContent = `${(remain/1000).toFixed(1)} –∫–º`;
          $eta.textContent = 'ETA ‚Äî';
        } else {
          $dist.textContent = '‚Äî –∫–º'; $eta.textContent = 'ETA ‚Äî';
        }
        return;
      }

      $dist.textContent = `${(remainRoute/1000).toFixed(1)} –∫–º`;
      const next = getNextStepByLocation(userLocKm);
      if (next){
        // ETA –∑–∞ –ø–ª–∞–Ω–æ–º —ñ –∑–∞ –ø–æ—Ç–æ—á–Ω–æ—é —à–≤–∏–¥–∫—ñ—Å—Ç—é
        // --- –°–µ—Ä–µ–¥–Ω—è —à–≤–∏–¥–∫—ñ—Å—Ç—å –¥–ª—è ETA ---
        function getAverageSpeed() {
          const valid = speedHistory.filter(s => s > 2);
          if (valid.length >= 2) return valid.reduce((a,b)=>a+b,0)/valid.length;
          // –Ø–∫—â–æ –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö ‚Äî –¥–µ—Ñ–æ–ª—Ç
          return (map.getZoom() >= 13) ? 45/3.6 : 75/3.6; // –º/—Å
        }
        const avgSpeed = getAverageSpeed();
        const etaPlanSec = (totalDistance > 0) ? ((remainRoute / totalDistance) * totalDuration) : totalDuration;
        const etaSpeedSec = (isMoving && avgSpeed > 2) ? (remainRoute / Math.max(avgSpeed, 0.1)) : etaPlanSec;
        // –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞—Ç—Ä–∏–º–∫–∏ (—Å–≤—ñ—Ç–ª–æ—Ñ–æ—Ä–∏/–º–∞–Ω–µ–≤—Ä–∏), —è–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ
        let penalty = 0;
        if (trafficLights) penalty = computeTrafficLightPenalty(userLocKm, remainRoute);
        let etaSelectedRaw = (etaMode === 'speed') ? etaSpeedSec : etaPlanSec;
        etaSelectedRaw += penalty;
        // –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –æ–∫—Ä–µ–º–æ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É
        if (!window.__etaSmoothedPlan) window.__etaSmoothedPlan = etaPlanSec;
        if (!window.__etaSmoothedSpeed) window.__etaSmoothedSpeed = etaSpeedSec;
        window.__etaSmoothedPlan = window.__etaSmoothedPlan + (etaPlanSec - window.__etaSmoothedPlan) * 0.25;
        window.__etaSmoothedSpeed = window.__etaSmoothedSpeed + (etaSpeedSec - window.__etaSmoothedSpeed) * 0.25;
        const baseSmoothed = (etaMode === 'speed') ? window.__etaSmoothedSpeed : window.__etaSmoothedPlan;
        const etaSec = Math.max(0, Math.min(24*3600, baseSmoothed + penalty));
        const mins = Math.round(etaSec/60);
        $eta.textContent = `ETA ${secondsToETA(etaSec)} ‚Ä¢ ${mins} —Ö–≤`;
        // –û–Ω–æ–≤–ª—é—î–º–æ —è—Ä–ª–∏—á–æ–∫ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞–Ω–µ–≤—Ä—É (–ø–ª–∞–≤–∞—é—á–∏–π)
        updateTurnBadge(descriptorForStep(next));
        updateTurnDistance(next._metersToManeuver);

        const lead = Math.min(SPEAK_MAX_DIST, Math.max(SPEAK_MIN_DIST, speedMps * SPEAK_LOOKAHEAD_SEC));
        if (spoken.idx !== next._index) resetSpokenFor(next._index);

        // –ù–µ –æ–∑–≤—É—á—É—î–º–æ ¬´—Å–∫–æ—Ä–æ¬ª, —è–∫—â–æ ¬´–∑–∞—Ä–∞–∑¬ª –±—É–¥–µ –∑–∞–Ω–∞–¥—Ç–æ —à–≤–∏–¥–∫–æ (–º–µ–Ω—à–µ 4 —Å–µ–∫)
        const secsToNow = (speedMps>0.5) ? (next._metersToManeuver / Math.max(speedMps,0.5)) : Infinity;
        if (!spoken.early && next._metersToManeuver <= lead && next._metersToManeuver > SPEAK_NOW_DIST && secsToNow > 4){
          const t = stepToSpeech(next, 'soon', next._metersToManeuver);
          if (t) { speak(t); spoken.early = true; }
        }
        if (!spoken.now && next._metersToManeuver <= SPEAK_NOW_DIST){
          const t = stepToSpeech(next, 'now');
          if (t) { speak(t); spoken.now = true; }
        }
      } else {
        $eta.textContent = 'ETA ‚Äî';
  updateTurnBadge(null);
        updateTurnDistance(NaN);
      }
    }
  }

  function onPositionError(err){ console.warn('GPS error', err); }

  document.getElementById('btnStart').onclick = startNav;
  document.getElementById('btnStop').onclick = stopNav;
  document.getElementById('btnShare').onclick = shareLink;
  let noticeTimer = null;

  // ===== –£—Ç—Ä–∏–º–∞–Ω–Ω—è –µ–∫—Ä–∞–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∏–º (Wake Lock + NoSleep fallback) =====
  const KEEP_AWAKE_KEY = 'NAV_KEEP_AWAKE';
  let keepAwakePref = (localStorage.getItem(KEEP_AWAKE_KEY) === '1');
  let wakeLock = null;
  let noSleep = null;

  function updateKeepAwakeUI(){
    if ($keepAwakeBtn){
      $keepAwakeBtn.textContent = keepAwakePref ? '–ï–∫—Ä–∞–Ω: –Ω–µ –≤–∏–º–∏–∫–∞—Ç–∏' : '–ï–∫—Ä–∞–Ω: –∞–≤—Ç–æ';
      $keepAwakeBtn.title = keepAwakePref ? '–ï–∫—Ä–∞–Ω –Ω–µ –≥–∞—Å–∏—Ç–∏–º–µ—Ç—å—Å—è (–Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± –≤–∏–º–∫–Ω—É—Ç–∏)' : '–î–æ–∑–≤–æ–ª–∏—Ç–∏ –Ω–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω –ø—ñ–¥ —á–∞—Å –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó';
    }
    if ($keepAwakeFab){
      $keepAwakeFab.textContent = keepAwakePref ? 'üí°' : 'üåô';
      $keepAwakeFab.title = keepAwakePref ? '–ï–∫—Ä–∞–Ω –Ω–µ –≥–∞—Å–∏—Ç–∏–º–µ—Ç—å—Å—è' : '–î–æ–∑–≤–æ–ª–∏—Ç–∏ –Ω–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω';
      if (keepAwakePref) {
        $keepAwakeFab.style.background = '#10b981'; // green
        $keepAwakeFab.style.color = 'white';
      } else {
        $keepAwakeFab.style.background = '#6b7280'; // gray
        $keepAwakeFab.style.color = 'white';
      }
    }
  }
  updateKeepAwakeUI();
  // ETA —Ä–µ–∂–∏–º —ñ –°–≤—ñ—Ç–ª–æ—Ñ–æ—Ä–∏
  const ETA_MODE_KEY = 'NAV_ETA_MODE'; // 'plan' | 'speed'
  const TRAFFIC_LIGHTS_KEY = 'NAV_TRAFFIC_LIGHTS'; // '1' | '0'
  let etaMode = (localStorage.getItem(ETA_MODE_KEY) === 'speed') ? 'speed' : 'plan';
  let trafficLights = (localStorage.getItem(TRAFFIC_LIGHTS_KEY) === '1');
  function updateEtaTrafficUI(){
    if ($btnEtaMode){
      $btnEtaMode.title = `–†–µ–∂–∏–º ETA: ${etaMode === 'plan' ? '–ø–ª–∞–Ω' : '—à–≤–∏–¥–∫—ñ—Å—Ç—å'}`;
      $btnEtaMode.textContent = '‚è±';
      if (etaMode === 'speed') {
        $btnEtaMode.style.background = '#10b981'; // green - speed mode active
        $btnEtaMode.style.color = 'white';
      } else {
        $btnEtaMode.style.background = '#3b82f6'; // blue - plan mode
        $btnEtaMode.style.color = 'white';
      }
    }
    if ($btnTraffic){
      $btnTraffic.title = `–°–≤—ñ—Ç–ª–æ—Ñ–æ—Ä–∏: ${trafficLights ? '–≤–∫–ª' : '–≤–∏–∫–ª'}`;
      $btnTraffic.textContent = 'üö¶';
      if (trafficLights) {
        $btnTraffic.style.background = '#10b981'; // green - enabled
        $btnTraffic.style.color = 'white';
        $btnTraffic.style.opacity = '1';
      } else {
        $btnTraffic.style.background = '#6b7280'; // gray - disabled
        $btnTraffic.style.color = 'white';
        $btnTraffic.style.opacity = '0.8';
      }
    }
  }
  updateEtaTrafficUI();
  function toggleEtaMode(){ etaMode = (etaMode === 'plan') ? 'speed' : 'plan'; localStorage.setItem(ETA_MODE_KEY, etaMode); updateEtaTrafficUI(); }
  function toggleTraffic(){ trafficLights = !trafficLights; localStorage.setItem(TRAFFIC_LIGHTS_KEY, trafficLights ? '1':'0'); updateEtaTrafficUI(); }
  if ($btnEtaMode) $btnEtaMode.addEventListener('click', toggleEtaMode);
  if ($btnTraffic) $btnTraffic.addEventListener('click', toggleTraffic);

  /* –≤–∏–¥–∞–ª–µ–Ω–æ –±–ª–æ–∫ –∫–∞–º–µ—Ä —à–≤–∏–¥–∫–æ—Å—Ç—ñ */

  async function requestWakeLock(){
    try {
      if ('wakeLock' in navigator && navigator.wakeLock?.request){
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          // –Ø–∫—â–æ —Å—Ç–æ—Ä—ñ–Ω–∫–∞ –∑–Ω–æ–≤—É –∞–∫—Ç–∏–≤–Ω–∞ —ñ –æ–ø—Ü—ñ—è —É–≤—ñ–º–∫–Ω–µ–Ω–∞ ‚Äî –ø–µ—Ä–µ–æ—Ç—Ä–∏–º–∞—î–º–æ –ª–æ–∫
          if (document.visibilityState === 'visible' && keepAwakePref){
            requestWakeLock().catch(()=>{});
          }
        });
      } else if (window.NoSleep){
        if (!noSleep) noSleep = new NoSleep();
        // –£ Safari –ø–æ—Ç—Ä—ñ–±–µ–Ω –∂–µ—Å—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ ‚Äî –≤–∏–∫–ª–∏–∫–∞—Ç–∏–º–µ–º–æ —ñ–∑ –∫–ª—ñ–∫—É –°—Ç–∞—Ä—Ç/–∫–Ω–æ–ø–∫–∏
        noSleep.enable();
      }
    } catch (e) {
      console.warn('WakeLock error:', e?.message || e);
    }
  }
  async function releaseWakeLock(){
    try { if (wakeLock) { await wakeLock.release(); } } catch(_) {}
    wakeLock = null;
    try { if (noSleep) { noSleep.disable(); } } catch(_) {}
  }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && keepAwakePref) {
      requestWakeLock().catch(()=>{});
    }
  });
  async function toggleKeepAwake(){
    keepAwakePref = !keepAwakePref;
    localStorage.setItem(KEEP_AWAKE_KEY, keepAwakePref ? '1' : '0');
    updateKeepAwakeUI();
    if (keepAwakePref) await requestWakeLock(); else await releaseWakeLock();
  }
  if ($keepAwakeBtn) $keepAwakeBtn.addEventListener('click', toggleKeepAwake);
  if ($keepAwakeFab) $keepAwakeFab.addEventListener('click', toggleKeepAwake);

  // FAB: open/close
  function closeFabSoon(){ setTimeout(()=>{ if ($fab) $fab.classList.remove('open'); }, 2000); }
  if ($fabToggle){
    $fabToggle.addEventListener('click', () => {
      if ($fab) $fab.classList.toggle('open');
      if ($fab?.classList.contains('open')) closeFabSoon();
    });
  }
  // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –ø—Ä–∏ –∫–ª—ñ–∫—É –ø–æ–∑–∞ –º–µ–Ω—é
  document.addEventListener('click', (e) => {
    if (!$fab) return;
    if (!$fab.contains(e.target)) $fab.classList.remove('open');
  }, true);

  function startNav(){
    if (watchId!=null) return;
    if (!navigator.geolocation){ alert('–ì–µ–æ–ª–æ–∫–∞—Ü—ñ—è –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º'); return; }

    $notice.style.display='block'; clearTimeout(noticeTimer);
    noticeTimer = setTimeout(()=>{$notice.style.display='none';}, 4000);

    followHard = true; autoCenter = true; setFollowUI();

    // –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á —É–≤—ñ–º–∫–Ω—É–≤ "–ù–µ –≥–∞—Å–∏—Ç–∏ –µ–∫—Ä–∞–Ω" ‚Äî –Ω–∞–º–∞–≥–∞—î–º–æ—Å—å —É–≤—ñ–º–∫–Ω—É—Ç–∏ –ª–æ–∫ –∑–∞—Ä–∞–∑ (—î –∂–µ—Å—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞)
    if (keepAwakePref) { requestWakeLock().catch(()=>{}); }

    watchId = navigator.geolocation.watchPosition(
      onPosition, onPositionError,
      { enableHighAccuracy:true, maximumAge:0, timeout:5000 }
    );
    speak('–ù–∞–≤—ñ–≥–∞—Ü—ñ—é —Ä–æ–∑–ø–æ—á–∞—Ç–æ');
  }

  function stopNav(){
    if (watchId!=null){
      navigator.geolocation.clearWatch(watchId); watchId=null;
      speak('–ù–∞–≤—ñ–≥–∞—Ü—ñ—é –∑—É–ø–∏–Ω–µ–Ω–æ'); clearTimeout(noticeTimer); $notice.style.display='none';
    }
  }

  function buildShareURL(payload){
    const base = `${location.origin}${location.pathname}`;
    const q = new URLSearchParams();
    try{
      const srcz = LZString.compressToEncodedURIComponent(JSON.stringify(payload));
      q.set('srcz', srcz);
    }catch(e){ console.warn('compress fail', e); }
    // –î–æ–¥–∞–π public=1, —è–∫—â–æ —Ö–æ—á–µ—à —à–∞—Ä–∏—Ç–∏ –±–µ–∑ –≤—Ö–æ–¥—É
    if (allowGuest) q.set('public','1');
    return `${base}?${q.toString()}`;
  }

  async function shareLink(){
    if (!routeGeoJSON){ showToast('–ú–∞—Ä—à—Ä—É—Ç —â–µ –Ω–µ –≥–æ—Ç–æ–≤–∏–π'); return; }
    const name = $title.textContent || '–ú–∞—Ä—à—Ä—É—Ç';
    const points = routeGeoJSON.geometry.coordinates;
    const payload = { name, points, manualSegments };
    const url = buildShareURL(payload);
    try{
      if (navigator.share){ await navigator.share({ title:name, url }); }
      else { await navigator.clipboard.writeText(url); showToast('–ü–æ—Å–∏–ª–∞–Ω–Ω—è —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ'); }
    }catch(e){ await navigator.clipboard.writeText(url); showToast('–ü–æ—Å–∏–ª–∞–Ω–Ω—è —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ'); }
  }

  map.on('style.load', applyUkrainianLabels);

  map.on('load', async ()=>{
    try{
      const { name, points, manualSegments: segs } = await loadRouteData();
      document.getElementById('routeTitle').textContent = name;
      manualSegments = Array.isArray(segs) ? segs : [];

      const waypoints = clampWaypoints(points, 25);
      try {
        await fetchDirections(waypoints);
      } catch (e) {
        if (String(e.message || '').includes('422') && waypoints.length > 2) {
          await fetchDirections([waypoints[0], waypoints[waypoints.length - 1]]);
        } else { throw e; }
      }

      addRouteToMap();
      addManualToMap();
      rebuildSnapFeatures();

      /* –≤–∏–¥–∞–ª–µ–Ω–æ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—é –∫–∞–º–µ—Ä */

      if (AUTO_START) startNav();
    }catch(e){ console.error(e); alert(e.message || e); }
  });
})();
</script>
</body>
</html>
