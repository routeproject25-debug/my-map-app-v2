<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>Експорт маршрутів (Firestore → Excel)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <!-- App config -->
  <script src="/config/config.js"></script>
  <!-- SheetJS (Excel) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- LZ-String (srcz) -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
  html, body { overflow-x: clip; } /* fallback: hidden */
  .table-wrap { overflow:auto; max-width:100%; }
    :root { --w: min(1400px, 96vw); }  /* ширше і адаптивно */
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; }
    .wrap { max-width:var(--w); margin:24px auto; padding:0 16px; }
    .card { background:#fff; border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.06); padding:16px; }
    h1 { margin:0 0 12px; font-size:20px; }

    .row { display:grid; gap:12px; }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    .row.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
    .row.cols-4 { grid-template-columns: 1fr 1fr 1fr 1fr; }
    .row.dates { grid-template-columns: minmax(180px,1fr) minmax(180px,1fr); gap:10px; }
    @media (max-width: 860px) { .row.cols-4 { grid-template-columns: 1fr 1fr; } }
    @media (max-width: 640px) { .row.cols-2, .row.cols-3, .row.cols-4, .row.dates { grid-template-columns: 1fr; } }

    label { display:block; font-size:13px; color:#555; margin:4px 0; }
    input[type="text"], input[type="date"], input[type="number"], select {
      width:100%; padding:8px 10px; border:1px solid #d5d9e0; border-radius:8px; background:#fff; font-size:14px;
    }
    .btn { padding:8px 12px; border:1px solid #cbd5e1; background:#fff; border-radius:8px; cursor:pointer; }
    .btn.primary { background:#2563eb; border-color:#2563eb; color:#fff; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn.sm { padding:4px 8px; font-size:12.5px; }
    .bar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .muted { color:#667085; font-size:12.5px; }
    .warn { color:#b91c1c; font-size:12px; }

    /* таблиця */
    table { width:100%; border-collapse:collapse; table-layout: fixed; }
    th, td { border:1px solid #e5e7eb; padding:6px 8px; font-size:13px; text-align:left; vertical-align: top; }
    th { background:#f1f5f9; position:relative; }
    .topbar { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }

    .pill { background:#eef2ff; color:#3730a3; padding:2px 8px; border-radius:999px; font-size:12px; }
    .stats { display:flex; gap:12px; flex-wrap:wrap; font-size:13px; color:#111827; }
    .stats .chip { background:#f3f4f6; border:1px solid #e5e7eb; border-radius:999px; padding:4px 10px; }

    /* картка з таблицею в межах контейнера */
.card.edge{
  width: 100%;
  margin-left: 0;
  margin-right: 0;
  border-radius: 12px;
}
    /* ширини/поведінка комірок */
    .col-code { width: 120px; }
    .cell-code { word-break: break-all; overflow-wrap: anywhere; white-space: normal; line-height:1.25; }

    /* Проміжні пункти */
    .col-via { width: clamp(220px, 28%, 520px); } /* або 40ch / 30% — як зручніше */
    .cell-via { white-space: normal; overflow-wrap: anywhere; word-break: break-word; line-height: 1.25; }

    .col-key { width: clamp(140px, 16vw, 200px); }
    .col-id  { width: clamp(120px, 18vw, 220px); }

    .col-status { width: clamp(140px, 18vw, 200px); }
    .col-comment { width: clamp(220px, 36vw, 520px); }
    .cell-comment { white-space: normal; overflow-wrap: anywhere; word-break: break-word; line-height:1.25; }

    .cell-key, .cell-id { position:relative; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right:28px; }
    .copy-btn { position:absolute; right:6px; top:50%; transform:translateY(-50%); border:0; background:transparent; cursor:pointer; font-size:14px; opacity:.75; }
    .copy-btn:hover { opacity:1; }

    /* сортування / фільтри в шапці */
    th.sortable { cursor:pointer; user-select:none; }
    th.sortable .s { font-size:11px; opacity:.6; margin-left:6px; }
    th.sortable.active .s { opacity:1; }
    thead tr.filters th { background:#fafafa; }
    thead tr.filters input, thead tr.filters select {
      width:100%; padding:4px 6px; border:1px solid #e5e7eb; border-radius:6px; font-size:12px; background:#fff;
    }
    .range { display:grid; grid-template-columns: 1fr 1fr; gap:6px; }

    /* === Ручки для зміни ширини колонок === */
    .col-resizer{
  position:absolute; top:0; right:0; width:10px; height:100%;
  cursor:col-resize; user-select:none;
}
    .col-resizer:hover { background:rgba(37,99,235,.15); }
    .resizing .col-resizer { background:rgba(37,99,235,.25); }
	
	/* ==== Лівий сайдбар з чекбоксами ==== */
/* стало — сайдбар гнучкий і може згортатися */
.layout{
  display:grid;
  grid-template-columns: 1fr; /* одна колонка: результати тягнуться на всю, інше центруємо */
  gap:16px;
  align-items:start;
}

/* Діти .main розкладаються безпосередньо в грід .layout */
.layout .main{
  display: contents;
  min-width: 0; /* те саме, що було раніше */
}

/* Фільтри по центру, обмежуємо ширину */
.filters-card{
  grid-column: 1 / -1;     /* займає всю сітку, але… */
  max-width: 1100px;       /* …візуально не розляпується */
  justify-self: center;    /* центруємо */
}

/* Результати — фул-брід на всю ширину вікна */
.results-card{
  grid-column: 1 / -1;
  margin-left:  calc(50% - 50vw + 16px);
  margin-right: calc(50% - 50vw + 16px);
  max-width: 100vw;     /* щоб не розповзлось ширше вікна */
  border-radius: 12px;
}


.colpicker{
  grid-column: 1 / -1;           /* на всю ширину, як картка */
  position: static;              /* більше не sticky */
  background:#fff;
  border:1px solid #e5e7eb;
  border-radius:12px;
  padding:12px;
  max-height: none;
  overflow: visible;
}

.colpicker h3{ margin:0 0 8px; font-size:14px; }
.colpicker .list{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 8px 12px;
}
.colpicker label{ display:flex; align-items:center; gap:8px; font-size:13px; }
.colpicker .btns{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
/* ► Саме це додай */
.colpicker.is-hidden{ display:none; }
.filters-card.is-hidden{ display:none; }

/* кнопка-тогл зверху праворуч */
.coltoggle{ margin-left:8px; }

/* дрібниця: хай основний стовпець стискається */
.layout .main{ min-width:0; }

/* таблиця: ширина колонки ХАБ */
.col-hub { width: 120px; }

/* щоб «Результати» не розтягувались на всю ширину в межах layout */
.layout .main .card.edge { width:100%; margin-left:0; margin-right:0; border-radius:12px; }

/* мобільне: сайдбар під контент */
@media (max-width: 980px){
  .layout{ grid-template-columns: 1fr; }
  .colpicker{ position:static; }
  .filters-card{ grid-column: 1 / -1; }   /* щоб картка фільтрів не «тягнулася» в неіснуючу 2-гу колонку */
}

.card { overflow:hidden; }  /* щоб внутрішні елементи не «вигризали» горизонтальний скрол */

/* Хедер: зліва назва, справа кнопки */
.topbar.header-grid{
  display:grid;
  grid-template-columns: 260px 1fr; /* ліва колонка під назву */
  align-items:start;                /* кнопки зверху праворуч */
  gap:16px;
  margin-bottom:12px;               /* як і було */
}

/* Назва по центру блоку зліва */
.page-title{
  display:flex;
  justify-content:center;
  align-items:center;
  min-height:120px;                 /* щоб було «по центру» */
  background:#fff;
  border-radius:12px;
  box-shadow:0 2px 10px rgba(0,0,0,.06);
  padding:12px;
  text-align:center;
  font-size:20px;
  font-weight:600;
  margin:0;                         /* прибираємо дефолтний відступ h1 */
}

/* Кнопки вгорі праворуч */
.header-actions{
  display:flex;
  justify-content:flex-end;         /* ПРАВОРУЧ */
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}

/* Адаптив */
@media (max-width: 980px){
  .topbar.header-grid{ grid-template-columns: 1fr; }
  .page-title{ min-height:auto; }
  .header-actions{ justify-content:flex-start; }
}

/* Щоб короткі колонки не стискались зовсім */
#resTable th, #resTable td { min-width: 90px; }

/* Липкий верхній горизонтальний скрол поверх таблиці */
.results-card { position: relative; }
#xScroller{
  position: sticky;
  top: 8px;              /* якщо перекривається хедером – збільш це число */
  z-index: 20;
  height: 16px;          /* висота зони скролу */
  overflow-x: auto;
  overflow-y: hidden;
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  margin-bottom: 8px;
}
#xScroller::-webkit-scrollbar { height: 12px; }   /* товстіший скрол у WebKit */
#xScroller > div { height: 1px; }                 /* «доріжка» для ширини */

  </style>
  
  <!-- AUTH GUARD: /export — лише admin | logist -->
<script>
(function () {
  // ховаємо DOM, поки не перевіримо доступ
  document.documentElement.style.visibility = 'hidden';

  // локальна (всередині функції) копія конфіга, щоб не конфліктувати з нижнім const firebaseConfig
  const CFG = window.APP_CONFIG?.firebase;
if (!CFG) console.error('APP_CONFIG.firebase відсутній. Перевір /config/config.js і підключення <script src="/config/config.js">.');
try { firebase.apps?.length ? firebase.app() : firebase.initializeApp(CFG); } catch(e) {}
  const auth = firebase.auth();
  const db   = firebase.firestore();

  const loginURL = '/login.html?next=' + encodeURIComponent(location.pathname + location.search);

  // хелпер: показувати/оновлювати бейдж ролі у шапці (якщо елемент уже намальований)
  function setRoleBadge(r) {
    const el = document.getElementById('authRole');
    if (el) {
      el.textContent = `Роль: ${r || '—'}`;
      el.style.display = '';
    }
  }

  // при виході/перезавантаженні — відписатися від live-ролі
  window.addEventListener('beforeunload', () => { try { window.__roleUnsub?.(); } catch(_) {} });

  auth.onAuthStateChanged(async (u) => {
    if (!u) { location.replace(loginURL); return; }

    try {
      // ✅ ролі — лише з сервера, щоб не було "залипання" кешу
      const snap = await db.collection('users').doc(u.uid).get({ source: 'server' });
      const role = snap.exists ? (snap.data().role || 'pending') : 'pending';

      // зробимо роль доступною нижнім скриптам
      window.__userRole = role;
      setRoleBadge(role);

      // якщо ще не підтверджений або без прав — одразу назад на логін
      if (role === 'pending') {
        alert('Ваш акаунт очікує підтвердження адміністратором.');
        location.replace(loginURL); return;
      }
      if (!['admin','logist','user','security'].includes(role)) {
  alert('Недостатньо прав для сторінки Експорту.');
  location.replace(loginURL); return;
}

      // ❗ Live-оновлення ролі: якщо адмін змінить роль у процесі — одразу реагуємо
      try {
        window.__roleUnsub?.();
        window.__roleUnsub = db.collection('users').doc(u.uid).onSnapshot((ds) => {
          const r = ds.exists ? (ds.data().role || 'pending') : 'pending';
          window.__userRole = r;
          setRoleBadge(r);
          if (r === 'pending' || !['admin','logist','user','security'].includes(r)) {
  alert('Доступ відкликано або роль змінено. Потрібен повторний вхід.');
  location.replace(loginURL);
}
        });
      } catch (_) {}

      // все добре — показуємо DOM
      document.documentElement.style.visibility = '';
    } catch (e) {
      console.error('Role check failed:', e);
      location.replace(loginURL);
    }
  });
})();
</script>
</head>
<body>
<header class="top">
  <nav style="display:flex;gap:16px;align-items:center;">
    <a href="/">🏠 Карта</a>
    <a href="/export/">📤 Експорт</a>
    <a href="/import/">📥 Імпорт</a>
  </nav>
  <div class="authbar">
    <span id="authInfo">Перевірка…</span>
    <span id="authRole" class="role-badge" style="display:none;"></span>
    <button id="btnLogout" class="btn" style="display:none;">Вийти</button>
    <span id="status" class="pill">З’єднання…</span>
  </div>
</header>

  <div class="wrap">
    <div class="topbar header-grid">
  <h1 class="page-title">Експорт маршрутів<br>(Firestore → Excel)</h1>

  <div class="header-actions">
    <a class="btn" href="/index.html">← До карти</a>
    <button id="btnToggleFilters" class="btn coltoggle">☰ Фільтри</button>
    <button id="btnToggleSidebar" class="btn coltoggle">☰ Поля таблиці</button>
  </div>
</div>

<div class="layout">
  <aside id="columnPicker" class="colpicker"></aside>

  <div class="main">
    <div class="card filters-card" style="margin-bottom:12px;">
      <div id="filtersArea">
        <div class="row cols-2">
          <div>
            <label>Фільтр: Від</label>
            <input id="fromName" type="text" placeholder="Почни вводити..." list="directoryList" autocomplete="off">
          </div>
          <div>
            <label>Фільтр: До</label>
            <input id="toName" type="text" placeholder="Почни вводити..." list="directoryList" autocomplete="off">
          </div>
        </div>

        <div class="row cols-2" style="margin-top:12px;">
          <div>
            <label>Тип</label>
            <select id="routeType">
              <option value="">— будь-який —</option>
              <option value="Основний">Основний</option>
              <option value="Альтернативний1">Альтернативний1</option>
              <option value="Альтернативний2">Альтернативний2</option>
            </select>
          </div>
          <div>
            <label>Оновлено: з → по</label>
            <div class="row dates">
              <input id="dateFrom" type="date">
              <input id="dateTo" type="date">
            </div>
          </div>
        </div>

        <div class="row cols-4" style="margin-top:12px;">
          <div>
            <label>Виробничий підрозділ (у Від або До)</label>
            <select id="unitFilter"><option value="">— будь-який —</option></select>
          </div>
          <div>
            <label>Відстань, км — від</label>
            <input id="distMin" type="number" step="0.001" placeholder="мін.">
          </div>
          <div>
            <label>Відстань, км — до</label>
            <input id="distMax" type="number" step="0.001" placeholder="макс.">
          </div>
          <div>
            <label>Логіст</label>
            <input id="logistFilter" type="text" placeholder="Почни вводити..." list="logistsList" autocomplete="off">
            <datalist id="logistsList"></datalist>
            <div id="logistsMsg" class="warn" style="display:none;margin-top:4px"></div>
          </div>
        </div>

        <div class="bar" style="margin-top:12px;">
          <button id="btnPreview" class="btn" disabled>👁️ Попередній перегляд</button>
          <button id="btnExport" class="btn primary" disabled>📥 Експорт у Excel</button>
          <button id="btnRefresh" class="btn" disabled>🔄 Оновити базу</button>
          <button id="btnExportJson" class="btn">JSON (видимі)</button>
          <button id="btnExportJsonAll" class="btn ghost" title="Довантажить усі сторінки і збереже в JSON">JSON (усі сторінки)</button>
          <span class="muted">Порожні фільтри = не обмежувати. Якщо Firestore попросить індекс — створіть, за посиланням із консолі.</span>
        </div>

        <datalist id="directoryList"></datalist>
      </div>
    </div>

   <div class="card results-card">
      <div class="bar" style="justify-content:space-between; margin-bottom:8px;">
        <strong>Результати</strong>
        <span class="muted" id="countInfo">Натисніть «Попередній перегляд»</span>
      </div>

      <div class="stats" id="statsInfo" style="display:none; margin-bottom:8px;">
        <div class="chip" id="statMax">Найбільша: —</div>
        <div class="chip" id="statMin">Найменша: —</div>
        <div class="chip" id="statAvg">Середня: —</div>
      </div>

      <!-- Пагінація / дії -->
      <div class="bar" id="moreBox" style="gap:6px; display:none; margin:6px 0 10px;">
        <button id="btnMore" class="btn sm">+ Завантажити ще</button>
        <button id="btnAll" class="btn sm">Завантажити все</button>
        <button id="btnClearFilters" class="btn sm">Очистити фільтри таблиці</button>
        <button id="btnAutosize" class="btn sm">↔️ Автоширина колонок</button>
      </div>
<!-- Липкий верхній горизонтальний скрол -->
<div id="xScroller"><div></div></div>

      <div class="table-wrap">
        <table id="resTable">
          <colgroup>
            <!-- 16 колонок з урахуванням нових «Статус» і «Причина відхилення» -->
			<col class="col-hub">
            <col class="col-code"><col class="col-code">
            <col><col><col class="col-via">  <!-- Від, До, Проміжні -->
            <col><col><col>                  <!-- Відстань, Тип, Логіст -->
            <col class="col-status"><col class="col-comment"> <!-- Статус, Причина -->
            <col>             <!-- Оновлено -->
            <col class="col-key"> <!-- Код маршруту -->
            <col class="col-id">  <!-- ID -->
            <col>                 <!-- Карта -->
            <col>                 <!-- Погодження -->
            <col>                 <!-- Навігатор -->
            <col>                 <!-- JSON -->

          </colgroup>
<thead>
  <!-- Рядок заголовків -->
  <tr>
    <th class="sortable" data-sort="hub"           data-colkey="hub">ХАБ <span class="s">↕</span></th>
    <th class="sortable" data-sort="fromCode"      data-colkey="fromCode">Код Від <span class="s">↕</span></th>
    <th class="sortable" data-sort="toCode"        data-colkey="toCode">Код До <span class="s">↕</span></th>
    <th class="sortable" data-sort="fromName"      data-colkey="fromName">Від <span class="s">↕</span></th>
    <th class="sortable" data-sort="toName"        data-colkey="toName">До <span class="s">↕</span></th>
    <th class="sortable" data-sort="viaNames"      data-colkey="via">Проміжні пункти <span class="s">↕</span></th>
    <th class="sortable" data-sort="distance_km"   data-colkey="distance">Відстань, км <span class="s">↕</span></th>
    <th class="sortable" data-sort="type"          data-colkey="type">Тип <span class="s">↕</span></th>
    <th class="sortable" data-sort="logisticName"  data-colkey="logist">Логіст <span class="s">↕</span></th>
    <th class="sortable" data-sort="statusLabel"   data-colkey="status">Статус погодження <span class="s">↕</span></th>
    <th class="sortable" data-sort="rejectComment" data-colkey="comment">Причина відхилення <span class="s">↕</span></th>
    <th class="sortable" data-sort="updatedAtRaw"  data-colkey="updated">Оновлено <span class="s">↕</span></th>
    <th class="sortable" data-sort="routeKey"      data-colkey="routeKey">Код маршруту <span class="s">↕</span></th>
    <th class="sortable" data-sort="id"            data-colkey="id">ID <span class="s">↕</span></th>
    <th data-colkey="map">Карта</th>
    <th data-colkey="review">Погодження</th>
    <th data-colkey="navigator">Навігатор</th>
    <th data-colkey="json">JSON</th>
  </tr>

  <!-- Рядок фільтрів (без змін по суті) -->
  <tr class="filters">
    <th><input id="f_hub" type="text" placeholder="пошук…"></th>
    <th><input id="f_fromCode" type="text" placeholder="пошук…"></th>
    <th><input id="f_toCode" type="text" placeholder="пошук…"></th>
    <th><input id="f_fromName" type="text" placeholder="пошук…" list="directoryList"></th>
    <th><input id="f_toName" type="text" placeholder="пошук…" list="directoryList"></th>
    <th><input id="f_via" type="text" placeholder="проміжні…"></th>
    <th>
      <div class="range">
        <input id="f_distMin" type="number" step="0.001" placeholder="мін.">
        <input id="f_distMax" type="number" step="0.001" placeholder="макс.">
      </div>
    </th>
    <th>
      <select id="f_type">
        <option value=""></option>
        <option value="Основний">Основний</option>
        <option value="Альтернативний1">Альтернативний1</option>
        <option value="Альтернативний2">Альтернативний2</option>
      </select>
    </th>
    <th><input id="f_logist" type="text" placeholder="логіст…" list="logistsList"></th>
    <th>
      <select id="f_status">
        <option value=""></option>
        <option>Погоджено</option>
        <option>Відхилено</option>
        <option>Очікує</option>
      </select>
    </th>
    <th><input id="f_comment" type="text" placeholder="коментар…"></th>
    <th>
      <div class="range">
        <input id="f_dateFrom" type="date">
        <input id="f_dateTo" type="date">
      </div>
    </th>
    <th><input id="f_routeKey" type="text" placeholder="пошук…"></th>
    <th><input id="f_id" type="text" placeholder="пошук…"></th>
    <th></th>  <!-- для "Карта" -->
    <th></th>  <!-- для "Погодження" -->
    <th></th>  <!-- для "Навігатор" -->
    <th></th>  <!-- для "JSON" -->

  </tr>
</thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/* === Навігаційні константи === */
const MAP_URL = '/index.html';
const NAVIGATE_PAGE = '/navigate.html';
const DEFAULT_PROFILE = 'driving';
const REVIEW_PAGE = '/review.html';

/* --- глобальний логер --- */
window.addEventListener('error', (e) => {
  console.error('Global error:', e.message, 'at', e.filename, e.lineno);
  try { document.getElementById('status').textContent = 'Помилка скрипта'; } catch(_) {}
});

const statusEl = document.getElementById('status');
let db = null, auth = null;
let currentUser = null;
let currentRole = null;

try {
  // Додаток уже ініціалізовано guard-скриптом вище
  const app = firebase.app();
  db = firebase.firestore();
  auth = firebase.auth();

  statusEl.textContent = 'Підключено';
  // офлайн-кеш
  db.enablePersistence({ synchronizeTabs: true }).catch((e) => {
    console.warn('Persistence off:', e.code || e.message);
  });
} catch (e) {
  console.error('Init error:', e);
  statusEl.textContent = 'Помилка ініціалізації';
}

/* ---------- Auth UI ---------- */
const authInfo = document.getElementById('authInfo');
const authRoleBadge = document.getElementById('authRole');
const btnLogout = document.getElementById('btnLogout');
const btnPreview = document.getElementById('btnPreview');
const btnExport  = document.getElementById('btnExport');
const btnRefresh = document.getElementById('btnRefresh');
const btnMore    = document.getElementById('btnMore');
const btnAll     = document.getElementById('btnAll');
const btnClearFilters = document.getElementById('btnClearFilters');
const btnAutosize = document.getElementById('btnAutosize');
const btnExportJson     = document.getElementById('btnExportJson');
const btnExportJsonAll  = document.getElementById('btnExportJsonAll');

function setBusy(b){
  btnPreview.disabled = b || !currentUser;
  btnExport.disabled  = b || !currentUser;
  btnRefresh.disabled = b || !currentUser;
  btnExportJson.disabled    = b || !currentUser;
btnExportJsonAll.disabled = b || !currentUser;
  if (btnMore) btnMore.disabled = b;
  if (btnAll)  btnAll.disabled  = b;
  if (btnClearFilters) btnClearFilters.disabled = b;
  if (btnAutosize) btnAutosize.disabled = b;
  statusEl.textContent = b ? 'Виконується…' : (currentUser ? 'Готово' : 'Увійдіть');
}

btnLogout.addEventListener('click', async () => { try{ await auth.signOut(); }catch(e){ console.warn(e); } });

auth?.onAuthStateChanged(async (u) => {
  currentUser = u || null;
  if (!u){
    const next = encodeURIComponent(location.pathname + location.search);
    location.replace(`/login.html?next=${next}`);
    return;
  }

  // роль уже перевірив верхній AUTH GUARD
  currentRole = window.__userRole || 'pending';

  authInfo.textContent = `Увійшли як ${u.email || u.uid}`;
  btnLogout.style.display = '';
  authRoleBadge.textContent = `Роль: ${currentRole}`;
  authRoleBadge.style.display = '';
  setBusy(false);
  
  // ⬇⬇⬇ ВСТАВ СЮДИ ⬇⬇⬇
  const syncRoleAndRerender = () => {
    const r = String(window.__userRole || '').toLowerCase();
    if (r && r !== currentRole) {
      currentRole = r;
      // оновлюємо бейдж і перемальовуємо таблицю (щоб з’явився лінк “Погодити”)
      try { authRoleBadge.textContent = `Роль: ${currentRole}`; reRender(); } catch(_) {}
    }
  };
  syncRoleAndRerender();
  setTimeout(syncRoleAndRerender, 100); // якщо guard допише роль із затримкою
  // ⬆⬆⬆ ВСТАВ СЮДИ ⬆⬆⬆

  try { await Promise.all([loadDirectory(), loadLogists(true)]); }
  catch (e) { console.warn(e); }
});

/* ---------- Довідник ---------- */
const dirByCode = {}, codeByName = {}; const unitsSet = new Set();
const DIR_CACHE_KEY = 'export.directoryCache.v1';
const DIR_CACHE_TTL_MS = 12 * 60 * 60 * 1000;

function fillDirectoryUI(rows){
  const list = document.getElementById('directoryList');
  const unitSelect = document.getElementById('unitFilter');
  list.innerHTML = '';
  unitSelect.querySelectorAll('option:not([value=""])').forEach(o=>o.remove());
  unitsSet.clear();
  Object.keys(dirByCode).forEach(k=>delete dirByCode[k]);
  Object.keys(codeByName).forEach(k=>delete codeByName[k]);

  for (const r of rows){
    const { code, name, company, unit } = r;
    dirByCode[code] = { name, company, unit };
    if(!(name in codeByName)) codeByName[name]=code;
    if (unit) unitsSet.add(unit);
    const opt = document.createElement('option');
    opt.value = name; opt.label = [name, unit, company].filter(Boolean).join(' • ');
    list.appendChild(opt);
  }
  Array.from(unitsSet).sort((a,b)=>a.localeCompare(b,'uk')).forEach(u=>{
    const o=document.createElement('option'); o.value=u; o.textContent=u; unitSelect.appendChild(o);
  });
}

async function loadDirectory(forceServer){
  if (!db || !currentUser) return;
  try{
    if (!forceServer){
      const raw = localStorage.getItem(DIR_CACHE_KEY);
      if (raw){
        const { ts, rows } = JSON.parse(raw);
        if (Array.isArray(rows) && Date.now() - ts < DIR_CACHE_TTL_MS){ fillDirectoryUI(rows); return; }
      }
    }
  }catch{}
  let snap = null;
  try {
    snap = await db.collection('directory').get({ source: forceServer ? 'server' : 'cache' });
  } catch {}
  if (!snap || snap.empty) { snap = await db.collection('directory').get({ source: 'default' }); }
  const rows = [];
  snap.forEach(doc=>{
    const d = doc.data()||{};
    rows.push({ code: doc.id, name: d.name || doc.id, company: d.company || '', unit: d.unit || '' });
  });
  fillDirectoryUI(rows);
  try{ localStorage.setItem(DIR_CACHE_KEY, JSON.stringify({ ts: Date.now(), rows })); }catch{}
}

/* ---------- Логісти ---------- */
const logistById = {}, logistIdByName = {};
const LOGISTS_CACHE_KEY = 'export.logistsCache.v1';
const LOGISTS_CACHE_TTL_MS = 12 * 60 * 60 * 1000;
const _norm = s => String(s||'').trim().toLowerCase();

function fillLogistsUI(rows){
  const list = document.getElementById('logistsList');
  list.innerHTML = '';
  for (const k in logistById) delete logistById[k];
  for (const k in logistIdByName) delete logistIdByName[k];
  rows.forEach(r=>{ logistById[r.id]=r; logistIdByName[r.name]=r.id;
    const opt=document.createElement('option'); opt.value=r.name; list.appendChild(opt);
  });
}

async function loadLogists(allowServer){
  const msg = document.getElementById('logistsMsg');
  const show = t => { msg.textContent = t || ''; msg.style.display = t ? 'block' : 'none'; };
  try{
    const raw = localStorage.getItem(LOGISTS_CACHE_KEY);
    if (raw){
      const { ts, rows } = JSON.parse(raw);
      if (Array.isArray(rows) && Date.now() - ts < LOGISTS_CACHE_TTL_MS){ fillLogistsUI(rows); show(''); return; }
    }
    if (!allowServer){ show('Увійдіть, щоб побачити список логістів.'); return; }
    let snap = null;
    try { snap = await db.collection('logists').get({ source: 'server' }); }
    catch(e){
      if (e && (e.code === 'permission-denied' || /insufficient permissions/i.test(e.message))){ show('Увійдіть, щоб побачити список логістів.'); return; }
      throw e;
    }
    let rows = [];
    snap.forEach(doc=>{
      const d = doc.data()||{};
      rows.push({ id: doc.id, name: d.name || doc.id, active: d.active !== false, sort: typeof d.sort === 'number' ? d.sort : 0 });
    });
    rows = rows.filter(r=>r.active).sort((a,b)=>(a.sort-b.sort)||a.name.localeCompare(b.name,'uk'));
    fillLogistsUI(rows);
    try{ localStorage.setItem(LOGISTS_CACHE_KEY, JSON.stringify({ ts: Date.now(), rows })); }catch{}
    show('');
  }catch(e){ console.error('logists load error:', e); show('Не вдалось завантажити логістів.'); }
}

function getLogistIdByInput(inputId){
  const name = (document.getElementById(inputId).value || '').trim();
  if (!name) return null;
  if (logistIdByName[name]) return logistIdByName[name];
  const n = _norm(name);
  for (const [label, id] of Object.entries(logistIdByName)){ if (_norm(label) === n) return id; }
  const cand = Object.entries(logistIdByName).filter(([label])=> _norm(label).includes(n));
  if (cand.length === 1) return cand[0][1];
  return null;
}

/* ---------- Хелпери ---------- */
function getCodeByNameInput(id){ const name=(document.getElementById(id).value||'').trim(); return codeByName[name] || ''; }
function nameByCode(code){ return (dirByCode[code]?.name)||''; }
function unitByCode(code){ return (dirByCode[code]?.unit)||''; }
function dayStartISO(d){ const x=new Date(d); x.setHours(0,0,0,0); return x.toISOString(); }
function dayEndISO(d){ const x=new Date(d); x.setHours(23,59,59,999); return x.toISOString(); }
function formatDate(dt){ if (!dt) return ''; const d=new Date(dt); if (isNaN(d)) return ''; const pad=n=>String(n).padStart(2,'0'); return `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; }
function normalizeForJson(val){
  if (val === undefined || val === null) return null;

  // Firestore спеціальні типи
  if (val instanceof firebase.firestore.Timestamp) return val.toDate().toISOString();
  if (val instanceof firebase.firestore.GeoPoint)  return { lat: val.latitude, lng: val.longitude };
  // DocumentReference → шлях
  if (val && typeof val === 'object' && typeof val.path === 'string' && val.parent) return val.path;

  if (Array.isArray(val)) return val.map(normalizeForJson);
  if (typeof val === 'object'){
    const out = {}; for (const [k,v] of Object.entries(val)) out[k] = normalizeForJson(v); return out;
  }
  return val;
}

function downloadJson(objOrArray, filename){
  const blob = new Blob([JSON.stringify(objOrArray, null, 2)], { type:'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = filename; a.click();
  setTimeout(()=> URL.revokeObjectURL(a.href), 5000);
}

/* ===== Верхній липкий скрол: синхронізація з .table-wrap ===== */
let _xScroller = null, _xInner = null, _xBound = false, _xRO = null;

function ensureXScroller(){
  _xScroller = document.getElementById('xScroller');
  if (!_xScroller){
    const card = document.querySelector('.results-card');
    if (!card) return;
    const s = document.createElement('div'); s.id = 'xScroller';
    const i = document.createElement('div'); s.appendChild(i);
    card.insertBefore(s, card.querySelector('.table-wrap'));
    _xScroller = s; _xInner = i;
  } else {
    _xInner = _xScroller.firstElementChild;
  }
}

function syncXWidth(){
  ensureXScroller();
  const table = document.getElementById('resTable');
  const wrap  = document.querySelector('.table-wrap');
  if (!_xScroller || !_xInner || !table || !wrap) return;
  _xInner.style.width = table.scrollWidth + 'px';
  _xScroller.scrollLeft = wrap.scrollLeft;
}

function bindXSync(){
  ensureXScroller();
  const wrap = document.querySelector('.table-wrap');
  if (!wrap || !_xScroller || _xBound) return;

  let lock = false;
  wrap.addEventListener('scroll', () => {
    if (lock) return; lock = true;
    _xScroller.scrollLeft = wrap.scrollLeft;
    lock = false;
  }, { passive:true });

  _xScroller.addEventListener('scroll', () => {
    if (lock) return; lock = true;
    wrap.scrollLeft = _xScroller.scrollLeft;
    lock = false;
  }, { passive:true });

  // стежимо за зміною ширини таблиці
  try {
    _xRO?.disconnect();
    _xRO = new ResizeObserver(syncXWidth);
    _xRO.observe(document.getElementById('resTable'));
  } catch(_) {}

  window.addEventListener('resize', debounce(syncXWidth, 120));
  _xBound = true;
}

const toNum = v => (v==='' || v==null) ? NaN : Number(v);

/* --- нормалізація точок --- */
function toLonLat(p){
  if (Array.isArray(p) && p.length>=2){ const a=Number(p[0]); const b=Number(p[1]); return (Math.abs(a)<=90 && Math.abs(b)<=180)?[b,a]:[a,b]; }
  if (typeof p==='string'){ const parts=p.split(/[;, ]+/).map(Number).filter(v=>!Number.isNaN(v)); if (parts.length>=2) return toLonLat(parts); }
  if (p && typeof p==='object'){ const lat=Number(p.lat ?? p.latitude ?? p.Lat ?? p.Latitude); const lon=Number(p.lon ?? p.lng ?? p.longitude ?? p.Lon ?? p.Lng ?? p.Longitude); if (!Number.isNaN(lat)&&!Number.isNaN(lon)) return [lon,lat]; }
  return null;
}
function normalizePoints(raw){
  if (!raw) return null;
  if (raw.type==='Feature' && raw.geometry?.type==='LineString') return normalizePoints(raw.geometry.coordinates);
  if (raw.geometry?.type==='LineString' && Array.isArray(raw.geometry.coordinates)) return normalizePoints(raw.geometry.coordinates);
  if (raw.type==='FeatureCollection' && Array.isArray(raw.features)){ const f=raw.features.find(f=>f.geometry?.type==='LineString'); if (f) return normalizePoints(f.geometry.coordinates); }
  if (Array.isArray(raw)){ const out=[]; for (const item of raw){ const pt=toLonLat(item); if (pt && Number.isFinite(pt[0]) && Number.isFinite(pt[1])) out.push(pt); } return out.length?out:null; }
  return null;
}
  /* ===== ZIP helpers ===== */
function downloadBlob(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 5000);
}

// Безпечні і короткі імена файлів
function safeName(s, max = 120){
  return String(s || '')
    .replace(/[<>:"/\\|?*\x00-\x1F]/g, '_')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, max);
}

/* 
 * Експорт: кожен маршрут окремим JSON у ZIP
 * rows — ті самі рядки, які ти віддавав у exportJsonFromRows
 */
async function exportJsonZipFromRows(rows){
  if (!rows || !rows.length){
    alert('Немає рядків для експорту.');
    return;
  }

  const zip = new JSZip();
  const folder = zip.folder('routes');

  // індекс: для зручного перегляду складу архіву
  const index = [];

  // Назва архіву
  const ts = new Date();
  const pad = n => String(n).padStart(2,'0');
  const zipName = `routes_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.zip`;

  // Наповнюємо ZIP файлами
  let i = 0;
  for (const r of rows){
    const raw = r.raw || {};
    const jsonObj = Object.assign({ id: r.id }, normalizeForJson(raw));
    const pretty = `${r.fromName || ''} → ${r.toName || ''}`.trim();
    const base =
      safeName(
        `route_${r.routeKey ? r.routeKey + '_' : ''}${r.id || ''}_${pretty || ''}`
      ) || `route_${i+1}`;

    folder.file(`${base}.json`, JSON.stringify(jsonObj, null, 2));
    index.push({
      id: r.id,
      routeKey: r.routeKey || null,
      name: pretty || null,
      updatedAt: r.updatedAtRaw || null,
      distance_km: Number.isFinite(r.distance_km) ? r.distance_km : null
    });

    // щоб не "заморожувати" UI на дуже великих вибірках
    if (++i % 200 === 0) await new Promise(requestAnimationFrame);
  }

  // докладаємо індекс
  zip.file('index.json', JSON.stringify(index, null, 2));

  // Генеруємо архів з компресією
  const blob = await zip.generateAsync(
    { type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } },
    (meta) => { try { statusEl.textContent = `Архівується… ${meta.percent.toFixed(1)}%`; } catch(_) {} }
  );

  downloadBlob(blob, zipName);
  try { statusEl.textContent = 'Готово'; } catch(_) {}
}

/* === UTF-8 Base64 === */
function b64encodeUtf8(objOrString){
  const s = typeof objOrString === 'string' ? objOrString : JSON.stringify(objOrString);
  const bytes = new TextEncoder().encode(s); let bin='';
  for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]); return btoa(bin);
}

/* округлення координат */
const round6 = n => Math.round(n * 1e6) / 1e6;
const roundCoords = arr => (arr || []).map(([lng,lat]) => [round6(lng), round6(lat)]);

/* нормалізація домальованих сегментів */
function normalizeSegments(source){
  const segments=[];
  function pushLine(arr){ if (!Array.isArray(arr)) return; const pts=arr.map(toLonLat).filter(Boolean); if (pts.length>=2) segments.push(pts); }
  function scan(val){
    if (!val) return;
    if (val.type==='FeatureCollection' && Array.isArray(val.features)){ val.features.forEach(f=>{ if (f?.geometry?.type==='LineString') pushLine(f.geometry.coordinates); if (f?.geometry?.type==='MultiLineString') (f.geometry.coordinates||[]).forEach(pushLine); }); return; }
    if (val.type==='Feature' && val.geometry) return scan(val.geometry);
    if (val.type==='LineString' && Array.isArray(val.coordinates)) return pushLine(val.coordinates);
    if (val.type==='MultiLineString' && Array.isArray(val.coordinates)) return val.coordinates.forEach(pushLine);
    if (Array.isArray(val)){ if (val.length && Array.isArray(val[0])) return pushLine(val); if (val.length && typeof val[0]==='object'){ const pts=val.map(toLonLat).filter(Boolean); if (pts.length>=2) return segments.push(pts); val.forEach(scan); return; } if (val.length && typeof val[0]==='string') return pushLine(val); }
    if (typeof val==='object'){ for (const [k,v] of Object.entries(val)){ if (/(ruler|manual|line|path|segment|polyline|draw)/i.test(k)) scan(v); } }
  }
  scan(source); return segments;
}

/* ---------- Витяг «Проміжних пунктів» ---------- */
function extractViaList(d){
  const acc = [];
  const seen = new Set();
  const push = (s) => {
    const t = String(s || '').trim();
    if (!t) return;
    const key = t.toLowerCase();
    if (!seen.has(key)) { seen.add(key); acc.push(t); }
  };
  const mapCode = (code) => nameByCode(code) || String(code || '').trim();

  const splitNames = s => String(s || '')
    .split(/[\|,;]|[–—-]|→/g)
    .map(x => x.trim())
    .filter(Boolean);

  ['intermediateText','viaNames','midNames','waypointNames','stopsNames'].forEach(k => {
    const v = d[k];
    if (Array.isArray(v)) v.forEach(push);
    else if (typeof v === 'string') splitNames(v).forEach(push);
  });

  ['intermediateCodes','viaCodes','midCodes','waypointCodes','stopsCodes'].forEach(k => {
    const v = d[k];
    if (Array.isArray(v)) v.forEach(c => push(mapCode(c)));
    else if (typeof v === 'string') splitNames(v).forEach(c => push(mapCode(c)));
  });

  ['intermediate','intermediates','via','vias','mid','mids','waypoints','midpoints','stops'].forEach(k => {
    const v = d[k];
    if (Array.isArray(v)) {
      for (const it of v) {
        if (typeof it === 'string') { splitNames(it).forEach(x => push(mapCode(x))); continue; }
        if (Array.isArray(it)) { const p = toLonLat(it); if (p) push(`${p[1].toFixed(6)}, ${p[0].toFixed(6)}`); continue; }
        if (it && typeof it === 'object') {
          if (it.name || it.label || it.title) { push(it.name || it.label || it.title); continue; }
          if (it.code) { push(mapCode(it.code)); continue; }
          const p = toLonLat(it); if (p) push(`${p[1].toFixed(6)}, ${p[0].toFixed(6)}`);
        }
      }
    } else if (typeof v === 'string') {
      splitNames(v).forEach(x => push(mapCode(x)));
    }
  });

  if (!acc.length) {
    const label = d.name || d.fromLabel || '';
    const parts = splitNames(label);
    if (parts.length >= 3) parts.slice(1, -1).forEach(push);
  }

  return acc;
}

/* ---------- ПАГІНАЦІЯ / СТАН ---------- */
const PAGE_SIZE = 1000;
let _baseQuery = null;
let _cursor = null;
let _hasMore = false;
let allRows = [];
let FORCE_SERVER = false;

/* ---------- Сортування ---------- */
const sortState = { key: 'updatedAtRaw', dir: -1 };

/* ---------- Мапінг статусів ---------- */
function toStatusLabel(v){
  const s = (typeof v === 'string') ? v.trim().toLowerCase() : v;

  const YES = new Set([
    'approved','approve','ok','okay','okey','allow','allowed',
    'accept','accepted','yes','true','y','done','success','passed'
  ]);
  const NO = new Set([
    'rejected','reject','denied','deny','declined','no','false',
    'not_approved','disallow','blocked','failed'
  ]);

  if (s === true || s === 1 || YES.has(s)) return 'Погоджено';
  if (s === false || s === 0 || NO.has(s))  return 'Відхилено';

  if (typeof s === 'string' && [
    'pending','in_review','inreview','review','waiting','wait','on_approval','submitted'
  ].includes(s)) return 'Очікує';

  // Якщо прилетіло вже готове україномовне значення — повертаємо як є
  return (typeof v === 'string') ? v : '';
}

function computeApprovalStatus(d){
  if (!d || typeof d !== 'object') return null;

  // 1) Найтиповіше: всередині d.approval
  const A = (d.approval && typeof d.approval === 'object') ? d.approval : null;
  if (A){
    if (A.status     !== undefined && A.status     !== null) return A.status;     // 'approved' | 'rejected' | 'pending' | ...
    if (A.approved   !== undefined && A.approved   !== null) return A.approved;   // true/false
    if (A.result     !== undefined && A.result     !== null) return A.result;     // 'approved' | 'rejected'
    if (A.decision   !== undefined && A.decision   !== null) return A.decision;   // 'approve' | 'reject'
    if (A.approvedAt) return true;                                                // сам факт наявності мітки часу
    if (A.updatedAt && (A.approvedBy || A.approver)) return true;                 // евристика
  }

  // 2) Поширені поля на верхньому рівні
  if (d.approvalStatus !== undefined && d.approvalStatus !== null) return d.approvalStatus;
  if (d.status         !== undefined && d.status         !== null) return d.status;
  if (d.state          !== undefined && d.state          !== null) return d.state;
  if (d.approved       !== undefined && d.approved       !== null) return d.approved;  // true/false
  if (d.approvedAt) return true;                                                       // топ-рівень
  if (d.decision)  return d.decision;

  return null;
}

/* ---------- Побудова запиту ---------- */
function buildBaseQuery(){
  if (!db || !currentUser) throw new Error('Необхідно увійти');
  let q = db.collection('routes');

  const fromCode = getCodeByNameInput('fromName');
  const toCode   = getCodeByNameInput('toName');
  const type     = document.getElementById('routeType')?.value;
  const df       = document.getElementById('dateFrom')?.value;
  const dt       = document.getElementById('dateTo')?.value;
  const logistId = getLogistIdByInput('logistFilter');

  if (fromCode) q = q.where('fromCode','==',fromCode);
  if (toCode)   q = q.where('toCode','==',toCode);
  if (type)     q = q.where('routeType','==',type);
  if (logistId) q = q.where('logisticId','==',logistId);

  q = q.orderBy('updatedAt','desc');
  if (df) q = q.where('updatedAt','>=', dayStartISO(df));
  if (dt) q = q.where('updatedAt','<=', dayEndISO(dt));

  return q;
}

function parseSnap(snap){
  const rows=[];
  snap.forEach(doc=>{
    const d=doc.data()||{};
    const viaArr = extractViaList(d);

   const statusValue = computeApprovalStatus(d);
const statusLabel = toStatusLabel(statusValue);

    const rejectComment =
      (d?.approval && 'comment' in d.approval ? (d.approval.comment || '') : '') ||
      (typeof d.comment === 'string' ? d.comment : '');

    rows.push({
      id: doc.id,
      routeKey: d.routeKey || '',
	  hub: d.hub || '',
      fromCode: d.fromCode||'',
      toCode: d.toCode||'',
      fromName: nameByCode(d.fromCode)||'',
      toName: nameByCode(d.toCode)||'',
      fromUnit: unitByCode(d.fromCode)||'',
      toUnit: unitByCode(d.toCode)||'',
      viaNames: viaArr.join(' • '),
      distance_km: (typeof d.distance_km==='number')? d.distance_km : NaN,
      type: d.routeType||'',
      logisticName: d.logisticName || '',
      logisticId: d.logisticId || '',
      statusRaw: statusValue, statusLabel, rejectComment,
      updatedAtRaw: d.updatedAt || null,
	  updatedAt: formatDate(d.updatedAt),
	  raw: d
    });
  });
  const lastDoc = snap.docs[snap.docs.length-1] || null;
  return { rows, lastDoc };
}

async function loadFirstPage(forceServer=false){
  FORCE_SERVER = !!forceServer;
  _baseQuery = buildBaseQuery();
  _cursor = null; _hasMore = false; allRows = [];
  let snap = null;
  try { snap = await _baseQuery.limit(PAGE_SIZE).get({source: FORCE_SERVER ? 'server' : 'default'}); }
  catch(e){
    console.warn('loadFirstPage fallback:', e?.message||e);
    try { snap = await _baseQuery.limit(PAGE_SIZE).get({source:'cache'}); } catch(_){}
  }
  if (!snap) return [];
  const { rows, lastDoc } = parseSnap(snap);
  allRows = rows;
  _cursor = lastDoc;
  _hasMore = !!lastDoc && snap.size === PAGE_SIZE;
  return rows;
}

async function loadNextPage(){
  if (!_baseQuery || !_cursor) return [];
  let snap = null;
  try { snap = await _baseQuery.startAfter(_cursor).limit(PAGE_SIZE).get({source: FORCE_SERVER ? 'server' : 'default'}); }
  catch(e){
    console.warn('loadNextPage fallback:', e?.message||e);
    try { snap = await _baseQuery.startAfter(_cursor).limit(PAGE_SIZE).get({source:'cache'}); } catch(_){}
  }
  if (!snap) return [];
  const { rows, lastDoc } = parseSnap(snap);
  _cursor = lastDoc;
  _hasMore = !!lastDoc && snap.size === PAGE_SIZE;
  allRows = allRows.concat(rows);
  return rows;
}

/* ---------- Фільтри (верхні) ---------- */
function applyTopFilters(rows){
  const unit = document.getElementById('unitFilter')?.value.trim() || '';
  const dmin = parseFloat(document.getElementById('distMin')?.value);
  const dmax = parseFloat(document.getElementById('distMax')?.value);
  const logistText = (document.getElementById('logistFilter')?.value || '').trim();
  const logistId = getLogistIdByInput('logistFilter');

  return rows.filter(r=>{
    if (unit && !(r.fromUnit === unit || r.toUnit === unit)) return false;
    const dist = r.distance_km;
    if (!Number.isFinite(dist)) return false;
    if (!Number.isNaN(dmin) && isFinite(dmin) && dist < dmin) return false;
    if (!Number.isNaN(dmax) && isFinite(dmax) && dist > dmax) return false;
    if (logistText && !logistId) {
      const n = _norm(logistText);
      if (!_norm(r.logisticName).includes(n)) return false;
    }
    return true;
  });
}

/* ---------- Фільтри (рядок у шапці таблиці) ---------- */
function getTableFilterState(){
  return {
    hub: document.getElementById('f_hub').value.trim(),
    fromCode:  document.getElementById('f_fromCode').value.trim(),
    toCode:    document.getElementById('f_toCode').value.trim(),
    fromName:  document.getElementById('f_fromName').value.trim(),
    toName:    document.getElementById('f_toName').value.trim(),
    via:       document.getElementById('f_via').value.trim(),
    distMin:   toNum(document.getElementById('f_distMin').value),
    distMax:   toNum(document.getElementById('f_distMax').value),
    type:      document.getElementById('f_type').value,
    logist:    document.getElementById('f_logist').value.trim(),
    status:    document.getElementById('f_status').value.trim(),
    comment:   document.getElementById('f_comment').value.trim(),
    df:        document.getElementById('f_dateFrom').value,
    dt:        document.getElementById('f_dateTo').value,
    routeKey:  document.getElementById('f_routeKey').value.trim(),
    id:        document.getElementById('f_id').value.trim(),
  };
}

function applyTableFilters(rows){
  const f = getTableFilterState();
  const normInc = (val, needle) => _norm(String(val||'')).includes(_norm(needle||''));
  const df = f.df ? new Date(dayStartISO(f.df)) : null;
  const dt = f.dt ? new Date(dayEndISO(f.dt))   : null;

  return rows.filter(r=>{
    if (f.hub && !normInc(r.hub, f.hub)) return false;
    if (f.fromCode && !normInc(r.fromCode, f.fromCode)) return false;
    if (f.toCode   && !normInc(r.toCode,   f.toCode))   return false;
    if (f.fromName && !normInc(r.fromName, f.fromName)) return false;
    if (f.toName   && !normInc(r.toName,   f.toName))   return false;
    if (f.via      && !normInc(r.viaNames, f.via)) return false;
    const dist = r.distance_km;
    if (Number.isFinite(f.distMin) && dist < f.distMin) return false;
    if (Number.isFinite(f.distMax) && dist > f.distMax) return false;
    if (f.type && r.type !== f.type) return false;
    if (f.logist && !normInc(r.logisticName, f.logist)) return false;
    if (f.status && r.statusLabel !== f.status) return false;
    if (f.comment && !normInc(r.rejectComment, f.comment)) return false;
    if ((df || dt) && r.updatedAtRaw){
      const d = new Date(r.updatedAtRaw);
      if (df && d < df) return false;
      if (dt && d > dt) return false;
    }
    if (f.routeKey && !normInc(r.routeKey, f.routeKey)) return false;
    if (f.id && !normInc(r.id, f.id)) return false;
    return true;
  });
}

/* ---------- Сортування обчислення ---------- */
function compareRows(a,b,key){
  const dir = sortState.dir;
  const getStr = s => String(s||'').toLocaleLowerCase('uk');
  switch(key){
    case 'distance_km': {
      const av = Number.isFinite(a.distance_km) ? a.distance_km : -Infinity;
      const bv = Number.isFinite(b.distance_km) ? b.distance_km : -Infinity;
      return (av - bv) * dir;
    }
    case 'updatedAtRaw': {
      const av = a.updatedAtRaw ? new Date(a.updatedAtRaw).getTime() : 0;
      const bv = b.updatedAtRaw ? new Date(b.updatedAtRaw).getTime() : 0;
      return (av - bv) * dir;
    }
    default: {
      const av = getStr(a[key]);
      const bv = getStr(b[key]);
      const r = av.localeCompare(bv,'uk');
      return r * dir;
    }
  }
}

function sortRows(rows){
  if (!sortState.key) return rows;
  const arr = rows.slice();
  arr.sort((a,b)=>{
    const r = compareRows(a,b,sortState.key);
    if (r !== 0) return r;
    const av = a.updatedAtRaw ? new Date(a.updatedAtRaw).getTime() : 0;
    const bv = b.updatedAtRaw ? new Date(b.updatedAtRaw).getTime() : 0;
    return (bv - av);
  });
  return arr;
}

function updateSortIcons(){
  document.querySelectorAll('#resTable thead th.sortable').forEach(th=>{
    const k = th.getAttribute('data-sort');
    const s = th.querySelector('.s');
    th.classList.toggle('active', sortState.key === k);
    if (!s) return;
    if (sortState.key !== k){ s.textContent = '↕'; return; }
    s.textContent = sortState.dir === 1 ? '▲' : '▼';
  });
}

/* ---------- Статистика ---------- */
function updateStats(rows){
  const statsBox = document.getElementById('statsInfo');
  if (!rows.length){ statsBox.style.display='none'; return; }
  const nums = rows.map(r=>r.distance_km).filter(Number.isFinite);
  if (!nums.length){ statsBox.style.display='none'; return; }
  const max = Math.max(...nums), min = Math.min(...nums), avg = nums.reduce((a,b)=>a+b,0)/nums.length;
  document.getElementById('statMax').textContent = `Найбільша: ${max.toFixed(3)}`;
  document.getElementById('statMin').textContent = `Найменша: ${min.toFixed(3)}`;
  document.getElementById('statAvg').textContent = `Середня: ${avg.toFixed(3)}`;
  statsBox.style.display='';
}

/* ---------- Навігатор ---------- */
async function buildNavigatePayloadById(routeId, prettyName){
  const ref = db.collection('routes').doc(routeId);
  const doc = await ref.get();
  if (!doc.exists) throw new Error('Маршрут не знайдено');
  const d = doc.data() || {};

  let points =
      normalizePoints(d.points) ||
      normalizePoints(d.coordinates) ||
      normalizePoints(d.route) ||
      normalizePoints(d.geojson) ||
      normalizePoints(d.geometry);

  if (!points) {
    const parts = [];
    if (d.start) { const p = toLonLat(d.start); if (p) parts.push(p); }
    if (Array.isArray(d.midpoints)) for (const m of d.midpoints){ const p=toLonLat(m); if (p) parts.push(p); }
    if (d.end) { const p = toLonLat(d.end); if (p) parts.push(p); }
    if (parts.length >= 2) points = parts;
  }
  if (!points || points.length < 2) throw new Error('У маршруті відсутній коректний масив точок');

  const manualSegments = normalizeSegments(d);
  return { name: prettyName || 'Маршрут', points: roundCoords(points), manualSegments: (manualSegments || []).map(roundCoords) };
}

function buildNavigateURLFromPayload(payloadObj){
  const base = `${location.origin}${NAVIGATE_PAGE}`;
  const q = new URLSearchParams();
  try { const json = JSON.stringify(payloadObj); const srcz = LZString.compressToEncodedURIComponent(json); q.set('srcz', srcz); } catch(e){ console.warn('Compression failed:', e); }
  try { q.set('src', b64encodeUtf8(payloadObj)); } catch(e){}
  return `${base}?${q.toString()}`;
}

function isMobileUA(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || ''); }
async function shareURL(url, title){
  if (isMobileUA() && navigator.share){ try { await navigator.share({ title: title || 'Маршрут', url }); return; } catch{} }
  try { await navigator.clipboard.writeText(url); alert('Посилання скопійовано у буфер обміну!'); }
  catch { prompt('Скопіюйте посилання вручну:', url); }
}

async function exportJsonFromRows(rows){
  // rows — це рядки таблиці з полем raw (повні дані документа)
  const data = rows.map(r => {
    const full = r.raw ? r.raw : {};        // на всяк випадок
    const normalized = (full);
    // гарантуємо наявність id у кожному записі
    return Object.assign({ id: r.id }, normalized);
  });

  const ts = new Date(); const pad = n=>String(n).padStart(2,'0');
  const fname = `routes_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.json`;
  downloadJson(data, fname);
}
/* ==== Керування видимістю колонок (чекбокси ліворуч) ==== */
const COLS_ORDER = [
  'hub','fromCode','toCode','fromName','toName','via','distance','type',
  'logist','status','comment','updated','routeKey','id','map','review','navigator','json'
];
const COL_LABEL = {
  hub:'ХАБ', fromCode:'Код Від', toCode:'Код До', fromName:'Від', toName:'До',
  via:'Проміжні пункти', distance:'Відстань, км', type:'Тип', logist:'Логіст',
  status:'Статус погодження', comment:'Причина відхилення', updated:'Оновлено',
  routeKey:'Код маршруту', id:'ID', map:'Карта', navigator:'Навігатор', json:'JSON', review:'Погодження'
};
const COL_INDEX = Object.fromEntries(COLS_ORDER.map((k,i)=>[k,i+1]));
const DEFAULT_VISIBLE = new Set(['hub','fromName','toName','via','distance','type','status','map', 'review']);
const VCOL_KEY = 'export.visibleCols.v2';
const EXCEL_EXCLUDE = new Set(['map','navigator','json', 'review']); // ці в Excel не додаємо

// --- Розподіл ширини видимих колонок, щоб прибрати "пустелю" праворуч ---
const COL_WEIGHTS = {
  via: 2.2, comment: 2.0, fromName: 1.3, toName: 1.3,
  hub: 1, fromCode: 1, toCode: 1, distance: 1, type: 1,
  logist: 1, status: 1, updated: 1, routeKey: 1, id: 1,
  map: 1, navigator: 1, json: 1
};

const COL_MIN_PX = {
  via: 280, comment: 240, fromName: 160, toName: 160,
  hub: 110, fromCode: 110, toCode: 110, distance: 120, type: 120,
  logist: 140, status: 140, updated: 160, routeKey: 160, id: 160,
  map: 120, navigator: 120, json: 120
};

/// Якщо видимих колонок мало і вони влазять у вікно — розтягуємо відсотками.
// Якщо у колонок вже задані ручні ширини (перетягування/автоширина) — нічого не чіпаємо.
function fitTableToViewport() {
  const card  = document.querySelector('.results-card');
  const wrap  = card?.querySelector('.table-wrap');
  const table = document.getElementById('resTable');
  if (!wrap || !table) return;

  const cols = table.querySelectorAll('colgroup col');
  const visibleKeys = COLS_ORDER.filter(k => visibleCols.has(k));

  // якщо є хоч одна задана ширина — поважаємо її і не перераховуємо
  const hasManual = Array.from(cols).some(c => c.style.width);
  if (hasManual){
    table.style.tableLayout = 'fixed';
    syncXWidth();
    return;
  }

  // Мінімально потрібна ширина для всіх видимих колонок
  const needed = visibleKeys.reduce((s, k) => s + (COL_MIN_PX[k] || 140), 0) + 24;
  const avail  = wrap.clientWidth;

  // очищаємо лише якщо немає ручних ширин
  cols.forEach(c => (c.style.width = ''));

  if (needed <= avail) {
    // Вміщається — розтягуємо відсотками з вагами
    table.style.tableLayout = 'fixed';
    const totalWeight = visibleKeys.reduce((s, k) => s + (COL_WEIGHTS[k] || 1), 0);
    visibleKeys.forEach(k => {
      const idx = COL_INDEX[k] - 1;
      if (!cols[idx]) return;
      const pct = ((COL_WEIGHTS[k] || 1) / totalWeight) * 100;
      cols[idx].style.width = pct.toFixed(4) + '%';
    });
  } else {
    // Не вміщається — «природна» ширина + горизонтальний скрол
    table.style.tableLayout = 'auto';
  }

  syncXWidth();
}

let visibleCols = new Set();
function loadVisibleCols(){
  try{
    const raw = localStorage.getItem(VCOL_KEY);
    if (raw){
      const arr = JSON.parse(raw);
      const ok = (arr||[]).filter(k=>COLS_ORDER.includes(k));
      if (ok.length){ visibleCols = new Set(ok); return; }
    }
  }catch{}
  visibleCols = new Set(DEFAULT_VISIBLE);
}
function saveVisibleCols(){
  try{ localStorage.setItem(VCOL_KEY, JSON.stringify([...visibleCols])); }catch{}
}
function setColVisible(key, show){
  const idx = COL_INDEX[key];
  if (!idx) return;

  // заголовок + фільтри + тіло
  const sel = `#resTable thead tr > *:nth-child(${idx}), #resTable tbody tr > *:nth-child(${idx})`;
  document.querySelectorAll(sel).forEach(el => { el.style.display = show ? '' : 'none'; });

  // ВАЖЛИВО: сам <col>, щоб прихована колонка не впливала на розкладку
  const colEl = document.querySelector(`#resTable colgroup col:nth-child(${idx})`);
  if (colEl) colEl.style.display = show ? '' : 'none';
}

function applyColumnVisibility(){
  COLS_ORDER.forEach(k => setColVisible(k, visibleCols.has(k)));
  fitTableToViewport();       // ← ключовий виклик
  enableResizableColumns();  // ← ДОДАВ
}

function buildColumnPickerUI(){
  loadVisibleCols();
  const box = document.getElementById('columnPicker');
  if (!box) return;
  box.innerHTML = `
    <h3>Поля таблиці</h3>
    <div class="list">
      ${COLS_ORDER.map(k=>`
        <label><input type="checkbox" data-colkey="${k}" ${visibleCols.has(k)?'checked':''}> ${COL_LABEL[k]}</label>
      `).join('')}
    </div>
    <div class="btns">
      <button type="button" class="btn sm" id="colsDefault">За замовчуванням</button>
      <button type="button" class="btn sm" id="colsAll">Усі</button>
      <button type="button" class="btn sm" id="colsNone">Жодні</button>
    </div>
  `;
  box.onchange = (e)=>{
    const cb = e.target.closest('input[type="checkbox"][data-colkey]'); if (!cb) return;
    const key = cb.getAttribute('data-colkey');
    if (cb.checked) visibleCols.add(key); else visibleCols.delete(key);
    saveVisibleCols(); applyColumnVisibility();
  };
  box.querySelector('#colsDefault')?.addEventListener('click', ()=>{
    visibleCols = new Set(DEFAULT_VISIBLE); saveVisibleCols(); buildColumnPickerUI(); applyColumnVisibility();
  });
  box.querySelector('#colsAll')?.addEventListener('click', ()=>{
    visibleCols = new Set(COLS_ORDER); saveVisibleCols(); buildColumnPickerUI(); applyColumnVisibility();
  });
  box.querySelector('#colsNone')?.addEventListener('click', ()=>{
    visibleCols = new Set(); saveVisibleCols(); buildColumnPickerUI(); applyColumnVisibility();
  });
}

/* ---------- Таблиця ---------- */
function renderTable(rows){
  // хто може бачити лінк на review
  const roleNow   = String(window.__userRole ?? currentRole ?? '').toLowerCase();
  const canReview = (roleNow === 'admin' || roleNow === 'security');

  const tb = document.querySelector('#resTable tbody');
  
  tb.innerHTML = rows.map(r=>`<tr data-id="${r.id}">
    <td>${r.hub || ''}</td>
    <td class="cell-code" title="${r.fromCode}">${r.fromCode}</td>
    <td class="cell-code" title="${r.toCode}">${r.toCode}</td>
    <td>${r.fromName}</td>
    <td>${r.toName}</td>
    <td class="cell-via">${r.viaNames || ''}</td>
    <td>${Number.isFinite(r.distance_km) ? r.distance_km.toFixed(3) : ''}</td>
    <td>${r.type}</td>
    <td>${r.logisticName || ''}</td>
    <td>${r.statusLabel || ''}</td>
    <td class="cell-comment">${r.rejectComment ? r.rejectComment : ''}</td>
    <td>${r.updatedAt}</td>
    <td class="cell-key" title="${r.routeKey || ''}">
      ${r.routeKey || ''}
      ${r.routeKey ? `<button class="copy-btn copy-key" data-val="${r.routeKey}" title="Скопіювати код">📋</button>` : ''}
    </td>
    <td class="cell-id" title="${r.id}">
      ${r.id}
      <button class="copy-btn copy-id" data-val="${r.id}" title="Скопіювати ID">📋</button>
    </td>
    <td><a href="${MAP_URL}?rid=${encodeURIComponent(r.id)}" target="_blank" rel="noopener">Відкрити</a></td>
<td>${
  (r.statusLabel === 'Погоджено')
    ? '—'
    : (canReview
        ? `<a href="${REVIEW_PAGE}?rid=${encodeURIComponent(r.id)}" target="_blank" rel="noopener">Погодити</a>`
        : '—')
}</td>
<td><button class="btn sm share-btn" data-id="${r.id}" data-name="${(r.fromName||'') + ' → ' + (r.toName||'')}">🔗 Поділитися</button></td>
<td><button class="btn sm json-one" data-id="${r.id}">JSON</button></td>
  </tr>`).join('');
  document.getElementById('countInfo').textContent = `Записів (після фільтру): ${rows.length}`;
  updateStats(rows);
}

/* ---------- Експорт у Excel ---------- */
function exportToExcel(rows){
  const keys = COLS_ORDER.filter(k => visibleCols.has(k) && !EXCEL_EXCLUDE.has(k));
  if (!keys.length){ alert('Оберіть хоча б одну колонку для експорту.'); return; }
  const header = keys.map(k => COL_LABEL[k]);

  const body = rows.map(r => keys.map(k => {
    switch(k){
      case 'hub':        return r.hub || '';
      case 'fromCode':   return r.fromCode || '';
      case 'toCode':     return r.toCode || '';
      case 'fromName':   return r.fromName || '';
      case 'toName':     return r.toName || '';
      case 'via':        return r.viaNames || '';
      case 'distance':   return Number.isFinite(r.distance_km) ? Number(r.distance_km.toFixed(3)) : '';
      case 'type':       return r.type || '';
      case 'logist':     return r.logisticName || '';
      case 'status':     return r.statusLabel || '';
      case 'comment':    return r.rejectComment || '';
      case 'updated':    return r.updatedAt || '';
      case 'routeKey':   return r.routeKey || '';
      case 'id':         return r.id || '';
      case 'map': {
        const mapUrl = `${location.origin}${MAP_URL}?rid=${encodeURIComponent(r.id)}`;
        return { t:'s', v:'🗺️ Відкрити', l:{ Target: mapUrl, Tooltip: 'Відкрити маршрут на карті' } };
      }
      default:           return '';
    }
  }));

  const ws = XLSX.utils.aoa_to_sheet([header, ...body]);
  ws['!cols'] = header.map(() => ({ wch: 18 }));
  ws['!autofilter'] = { ref: XLSX.utils.encode_range({ s:{c:0,r:0}, e:{c:header.length-1,r:body.length} }) };

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Маршрути');
  XLSX.writeFile(wb, 'routes_export.xlsx');
}

/* ---------- UI допоміжне ---------- */
function updatePagerUI(){
  const moreBox = document.getElementById('moreBox');
  moreBox.style.display = allRows.length ? '' : 'none';
  btnMore.style.display = _hasMore ? '' : 'none';
  btnAll.style.display  = _hasMore ? '' : 'none';
}

/* ---------- Оновити базу (форс із сервера) ---------- */
async function refreshAll(){
  try{
    setBusy(true);
    try{ localStorage.removeItem(DIR_CACHE_KEY); }catch{}
    try{ localStorage.removeItem(LOGISTS_CACHE_KEY); }catch{}
    await Promise.all([loadDirectory(true), loadLogists(true)]);
    await loadFirstPage(true);
    reRender();
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
}

/* ---------- Помилки Firestore ---------- */
function handleFirestoreError(e){
  console.error('Firestore error:', e);
  const msg = e?.message || '';
  if (e?.code === 'failed-precondition' && msg.includes('create it here')) {
    const m = msg.match(/https:\/\/console\.firebase\.google\.com\/[^\s"]+/);
    if (m && m[0]) { const url = m[0]; try { window.open(url, '_blank'); } catch(_) {} alert('Для цього запиту потрібен індекс у Firestore.\nЯ відкрив сторінку створення індексу у новій вкладці.\n\nПосилання:\n' + url); return; }
  }
  alert(msg || e);
}

/* ---------- Рендер ---------- */
function reRender(){
  let rows = applyTopFilters(allRows);
  rows = applyTableFilters(rows);
  rows = sortRows(rows);
  renderTable(rows);
  applyColumnVisibility();
  updatePagerUI();
  updateSortIcons();
  syncXWidth();           // ← додали
}

/* ---------- Події ---------- */
btnPreview.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    await loadFirstPage(true);   // ← було false
    reRender();
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});

btnMore.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    await loadNextPage();
    reRender();
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});

btnAll.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    const MAX_ROWS = 50000; // запобіжник
    while(_hasMore && allRows.length < MAX_ROWS){ await loadNextPage(); }
    reRender();
    if (_hasMore) alert(`Досягнуто ліміт ${MAX_ROWS.toLocaleString()} рядків. Звузьте фільтри або експортуйте частинами.`);
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});

btnExport.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    if (!allRows.length){ await loadFirstPage(false); }
    if (_hasMore){
      const agree = confirm(`Завантажити ВСІ сторінки перед експортом? Зараз у пам'яті ${allRows.length}+ рядків.`);
      if (agree){
        const MAX_ROWS = 50000;
        while(_hasMore && allRows.length < MAX_ROWS){ await loadNextPage(); }
        if (_hasMore) alert(`Досягнуто ліміт ${MAX_ROWS.toLocaleString()} рядків. Експорт по перших ${MAX_ROWS.toLocaleString()}.`);
      }
    }
    let rows = applyTopFilters(allRows);
    rows = applyTableFilters(rows);
    rows = sortRows(rows);
    exportToExcel(rows);
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});

btnRefresh.addEventListener('click', refreshAll);

document.querySelector('#resTable thead').addEventListener('click', (ev)=>{
  const th = ev.target.closest('th.sortable');
  if (!th) return;
  const key = th.getAttribute('data-sort');
  if (sortState.key === key) sortState.dir *= -1;
  else { sortState.key = key; sortState.dir = 1; }
  reRender();
});

function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
const onFilterChange = debounce(()=> reRender(), 200);
document.querySelector('#resTable thead').addEventListener('input', onFilterChange);
btnClearFilters.addEventListener('click', ()=>{
  document.querySelectorAll('#resTable thead .filters input, #resTable thead .filters select')
    .forEach(el=>{ el.value=''; });
  reRender();
});

/* Делегування кліків: Поділитися + Копіювати ID/Код */
document.querySelector('#resTable tbody').addEventListener('click', async (ev)=>{
  const shareBtn = ev.target.closest('.share-btn');
  if (shareBtn){
    const id = shareBtn.getAttribute('data-id');
    const prettyName = shareBtn.getAttribute('data-name') || 'Маршрут';
    try{
      setBusy(true);
      const payload = await buildNavigatePayloadById(id, prettyName);
      const url = buildNavigateURLFromPayload(payload);
      await shareURL(url, prettyName);
    }catch(e){ alert('Не вдалося створити посилання для навігатора: ' + (e?.message || e)); }
    finally{ setBusy(false); }
    return;
  }

const jsonOne = ev.target.closest('.json-one');
if (jsonOne){
  const id = jsonOne.getAttribute('data-id');
  try{
    setBusy(true);
    // знаходимо рядок у вже завантажених
    const row = allRows.find(x => x.id === id);
    if (row && row.raw){
      downloadJson(Object.assign({ id }, normalizeForJson(row.raw)), `route_${id}.json`);
    } else {
      // фолбек: дочитати документ напряму
      const doc = await db.collection('routes').doc(id).get({ source:'server' });
      const raw = doc.exists ? doc.data() : {};
      downloadJson(Object.assign({ id }, normalizeForJson(raw)), `route_${id}.json`);
    }
  }catch(e){ alert('Не вдалося вивантажити маршрут: ' + (e?.message || e)); }
  finally{ setBusy(false); }
  return;
}

  const copyBtn = ev.target.closest('.copy-btn');
  if (copyBtn){
    const val = copyBtn.getAttribute('data-val') || '';
    try{
      await navigator.clipboard.writeText(val);
      copyBtn.textContent = '✅';
      setTimeout(()=>{ copyBtn.textContent = '📋'; }, 1000);
    }catch{ prompt('Скопіюйте значення вручну:', val); }
  }
});

/* ---------- Розтягування та автоширина колонок ---------- */
const WIDTHS_KEY = 'export.tableWidths.v1';

function freezeTableWidths(){
  const table = document.getElementById('resTable');
  if (!table || !table.tHead || !table.tHead.rows.length) return;

  const headerRow = table.tHead.rows[0];
  const cols = Array.from(table.querySelector('colgroup').children);

  // Вмикаємо фіксований лейаут — він стабільний під час drag
  table.style.tableLayout = 'fixed';

  // Зберігаємо поточні фактичні ширини у px
  for (let i = 0; i < cols.length; i++){
    const th = headerRow.cells[i];
    const col = cols[i];
    if (!th || !col) continue;
    const w = Math.round(th.getBoundingClientRect().width);
    if (w > 0) col.style.width = w + 'px';
  }
}

function enableResizableColumns() {
  const table = document.getElementById('resTable');
  if (!table || !table.tHead || !table.tHead.rows.length) return;

  const headerRow = table.tHead.rows[0];
  const cols = Array.from(table.querySelector('colgroup').children);

  // прибираємо старі ручки (на випадок перевстановлення)
  headerRow.querySelectorAll('.col-resizer').forEach(el => el.remove());

  // додаємо нові, прив’язані до data-colkey
  Array.from(headerRow.cells).forEach((th) => {
    const key = th.dataset.colkey;
    if (!key || !COL_INDEX[key]) return;

    const colIdx = COL_INDEX[key] - 1;    // 0-based у <colgroup>
    const colEl = cols[colIdx];
    if (!colEl) return;

    const h = document.createElement('span');
    h.className = 'col-resizer';
    th.style.position = 'relative';
    th.appendChild(h);

    let startX = 0, startW = 0;

    const onMove = (e) => {
      const dx = e.clientX - startX;
      const w = Math.max(60, Math.min(900, startW + dx));
      colEl.style.width = w + 'px';
      table.classList.add('resizing');
    };

    const onUp = () => {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      table.classList.remove('resizing');
      saveColumnWidths();
    };

    h.addEventListener('mousedown', (e) => {
  e.preventDefault();

  // 1) заморозили поточні ширини — щоб нічого не стрибало
  freezeTableWidths();

  // 2) стартові координати після «заморозки»
  startX = e.clientX;
  startW = parseFloat(colEl.style.width) || th.getBoundingClientRect().width;

  // 3) легкий візуальний стан під час drag (і синхрон скролера)
  document.getElementById('resTable').classList.add('resizing');

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
});

    // Подвійний клік — автопідібрати ширину саме цієї колонки
    h.addEventListener('dblclick', () => {
      const w = measureColumnWidth(colIdx);
      colEl.style.width = w + 'px';
      saveColumnWidths();
    });
  });
}

function getTableFont(){
  const table = document.getElementById('resTable');
  const cs = getComputedStyle(table);
  return cs.font || `${cs.fontStyle||'normal'} ${cs.fontWeight||'400'} ${cs.fontSize||'13px'} ${cs.fontFamily||'system-ui'}`;
}

function measureColumnWidth(index){
  const table = document.getElementById('resTable');
  const sampleLimit = 200; // достатньо для адекватної оцінки
  const ctx = document.createElement('canvas').getContext('2d');
  ctx.font = getTableFont();

  const pad = 24; // падінг/іконки
  let max = 80;

  // заголовок
  const headText = (table.tHead.rows[0].cells[index].innerText || '').trim();
  max = Math.max(max, ctx.measureText(headText).width + pad);

  // фільтр у шапці (плейсхолдер / назва опції)
  const fcell = table.tHead.rows[1].cells[index];
  if (fcell){
    const input = fcell.querySelector('input,select');
    if (input){
      const txt = (input.value || input.placeholder || '').trim();
      if (txt) max = Math.max(max, ctx.measureText(txt).width + pad);
    }
  }

  // комірки тіла
  const rows = Array.from(table.tBodies[0].rows).slice(0, sampleLimit);
  for (const tr of rows){
    const txt = (tr.cells[index]?.innerText || '').trim();
    if (txt){
      max = Math.max(max, ctx.measureText(txt).width + pad);
    }
  }

  return Math.min(Math.max(Math.ceil(max), 60), 900);
}

function autosizeColumns(){
  const table = document.getElementById('resTable');
  const cols = Array.from(table.querySelector('colgroup').children);
  for (let i=0;i<cols.length;i++){
    const w = measureColumnWidth(i);
    cols[i].style.width = w + 'px';
  }
  saveColumnWidths();
  syncXWidth();
}

function saveColumnWidths(){
  try{
    const cols = document.querySelectorAll('#resTable colgroup col');
    const arr = Array.from(cols).map(c => (c.style.width || c.getBoundingClientRect().width + 'px'));
    localStorage.setItem(WIDTHS_KEY, JSON.stringify(arr));
  }catch{}
}

function restoreColumnWidths(){
  try{
    const raw = localStorage.getItem(WIDTHS_KEY);
    if (!raw) return;
    const arr = JSON.parse(raw);
    const cols = document.querySelectorAll('#resTable colgroup col');
    arr.forEach((w, i)=>{ if (cols[i]) cols[i].style.width = w; });
  }catch{}
}

btnAutosize.addEventListener('click', autosizeColumns);

/* ---------- Старт ---------- */
(async ()=>{
  if (!db) return;
  statusEl.textContent = 'Увійдіть';
  if (auth?.currentUser) { await Promise.all([loadDirectory(), loadLogists(true)]); }
  // підготовка колонок: відновити ширини і увімкнути перетягування
  restoreColumnWidths();
  enableResizableColumns();
  buildColumnPickerUI();
  fitTableToViewport();      // ← додали
  bindXSync();            // ← додали
})();

btnExportJson.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    if (!allRows.length){ await loadFirstPage(false); }
    let rows = applyTopFilters(allRows);
    rows = applyTableFilters(rows);
    rows = sortRows(rows);
    await exportJsonZipFromRows(rows);        // <-- замість exportJsonFromRows
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});

btnExportJsonAll.addEventListener('click', async ()=>{
  try{
    setBusy(true);
    if (!allRows.length){ await loadFirstPage(false); }
    while(_hasMore){ await loadNextPage(); }
    let rows = applyTopFilters(allRows);
    rows = applyTableFilters(rows);
    rows = sortRows(rows);
    await exportJsonZipFromRows(rows);        // <-- замість exportJsonFromRows
  }catch(e){ handleFirestoreError(e); }
  finally{ setBusy(false); }
});
/* ==== Тогл «Поля таблиці» як секції (показати/сховати) ==== */
const COLPICKER = document.getElementById('columnPicker');
const COLPICKER_STATE_KEY = 'export.colpickerHidden.v1';

function applyColpickerState(){
  const hidden = localStorage.getItem(COLPICKER_STATE_KEY) === '1';
  COLPICKER.classList.toggle('is-hidden', hidden);
}
applyColpickerState();

document.getElementById('btnToggleSidebar')?.addEventListener('click', () => {
  const hidden = COLPICKER.classList.toggle('is-hidden');
  localStorage.setItem(COLPICKER_STATE_KEY, hidden ? '1' : '0');
});

/* ==== Тогл «Фільтри» як секції (показати/сховати) ==== */
const FILTERS = document.querySelector('.filters-card');
const FILTERS_STATE_KEY = 'export.filtersHidden.v1';

function applyFiltersState(){
  const hidden = localStorage.getItem(FILTERS_STATE_KEY) === '1';
  FILTERS.classList.toggle('is-hidden', hidden);
}
applyFiltersState();

document.getElementById('btnToggleFilters')?.addEventListener('click', () => {
  const hidden = FILTERS.classList.toggle('is-hidden');
  localStorage.setItem(FILTERS_STATE_KEY, hidden ? '1' : '0');
});

</script>
</body>
</html>