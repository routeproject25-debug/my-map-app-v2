<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>‚úÖ –ü–æ–≥–æ–¥–∂–µ–Ω–Ω—è –º–∞—Ä—à—Ä—É—Ç—É</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Mapbox -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Mapbox GL Draw for proposal editing -->
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.css" rel="stylesheet" />

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<!-- App config -->
<script src="/config/config.js"></script>
  <style>
    :root { --line:#e5e7eb; --card:#fff; --muted:#6b7280; --nav-real:56px; }
    html, body { height:100%; }
    *{ box-sizing:border-box }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      background:#f8fafc;
    }
    /* –ø—Ä–∏—Ö–æ–≤—É—î–º–æ DOM –¥–æ –ø—Ä–æ—Ö–æ–¥–∂–µ–Ω–Ω—è guard-–∞ */
    html{ visibility:hidden }

    header{
      position:sticky; top:0; z-index:10;
      display:flex; align-items:center; gap:8px;
      padding:10px 12px; background:#0ea5e9; color:#fff
    }
    header a{ color:#fff; text-decoration:none }

    /* === Fullscreen review layout === */
    #reviewWrap{
      position:absolute; inset:var(--nav-real) 0 0 0;  /* –∑–∞–π–º–∞—î –≤–µ—Å—å –µ–∫—Ä–∞–Ω –ø—ñ–¥ —Ö–µ–¥–µ—Ä–æ–º */
      padding:8px;
    }
    .review-card{
      height:100%; width:100%;
      display:grid; grid-template-rows:auto 1fr auto;
      background:var(--card); border:1px solid var(--line);
      border-radius:12px; box-shadow:0 1px 10px rgba(0,0,0,.08);
    }

    .pad{ padding:12px }
    .title{ font-weight:800; font-size:20px; margin:0 0 6px }
    .muted{ color:var(--muted); font-size:13px }
    .chip{
      display:inline-block; border:1px solid var(--line); border-radius:999px;
      padding:4px 10px; background:#f3f4f6; font-size:12.5px
    }
    .btn{
      cursor:pointer; border:1px solid var(--line); background:#fff; border-radius:10px;
      padding:9px 12px; font-size:14px
    }
    .btn.good{ background:#e6f4ea; border-color:#22c55e }
    .btn.bad{ background:#fee2e2; border-color:#ef4444 }
    .btnRow{ display:flex; gap:8px; flex-wrap:wrap }
  .btn.active{ box-shadow:0 0 0 2px rgba(245,158,11,.35) inset; }

    label{ display:block; font-size:13px; margin:6px 0 4px }
    textarea{
      width:100%; min-height:90px; border:1px solid var(--line); border-radius:10px;
      padding:8px; resize:vertical
    }

    /* –∫–∞—Ä—Ç–∞ ‚Äî –∑–∞–π–º–∞—î –≤—Å—é —Å–µ—Ä–µ–¥–Ω—é ‚Äú—Ä—è–¥–∫—É‚Äù –∫–∞—Ä—Ç–∫–∏ */
    #map{ width:100%; height:100%; border-top:1px dashed var(--line); border-bottom:1px dashed var(--line); }

    .row{ display:grid; grid-template-columns:1fr 1fr; gap:12px }
    @media(max-width:900px){ .row{ grid-template-columns:1fr } }

  /* Proposal styles */
  /* –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –∫–Ω–æ–ø–∫–∏ —Ä–µ–∂–∏–º—ñ–≤ –±—ñ–ª—ñ; —Å—Ç–∞—é—Ç—å –∂–æ–≤—Ç–∏–º–∏ –ª–∏—à–µ –∫–æ–ª–∏ –∞–∫—Ç–∏–≤–Ω—ñ */
  .btn.warn{ background:#fff; border-color:var(--line) }
  .btn.warn.active{ background:#fef9c3; border-color:#f59e0b }
    .chip.proposal{ background:#fef9c3; border-color:#f59e0b }
    /* Make draw handles a bit more visible */
    .mapbox-gl-draw_point{ width:10px; height:10px; }

    /* Context menu for vertex actions */
    .ctx-menu{ position:fixed; z-index:1000; background:#fff; border:1px solid var(--line); border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,.18); padding:6px; min-width:180px; display:none; }
    .ctx-menu button{ width:100%; text-align:left; background:#fff; border:0; padding:8px 10px; border-radius:6px; cursor:pointer; font-size:14px; }
    .ctx-menu button:hover{ background:#f3f4f6; }
    /* –í—ñ–∑—É–∞–ª—å–Ω–∞ –ø—ñ–¥–∫–∞–∑–∫–∞ —Ä–µ–∂–∏–º—É –≤—Å—Ç–∞–≤–∫–∏: –∫—É—Ä—Å–æ—Ä-—Ö—Ä–µ—Å—Ç–∏–∫ */
    .pending-insert #map{ cursor: crosshair; }

    /* –°—Ö–æ–≤–∞—Ç–∏ —Å—Ç–∞—Ä–∏–π –¥–æ–∫, —è–∫—â–æ —â–µ —î –≤ DOM */
    #styleDock{ display:none !important; }
    /* === –õ–∞–∫–æ–Ω—ñ—á–Ω—ñ —ñ–∫–æ–Ω–∫–∏‚Äë–∫–Ω–æ–ø–∫–∏ (–≤–µ—Ä—Ö–Ω—ñ–π –ª—ñ–≤–∏–π –∫—É—Ç –Ω–∞ –∫–∞—Ä—Ç—ñ) === */
    .map-tools{
      position:fixed; left:8px; top:calc(var(--nav-real) + 8px); z-index:3500;
      display:flex; flex-direction:column; gap:8px;
    }
    .btn-icon{
      width:44px; height:44px; border-radius:12px; border:1px solid var(--line);
      background:#fff; box-shadow:0 2px 10px rgba(0,0,0,.12);
      display:flex; align-items:center; justify-content:center; cursor:pointer;
      font-size:20px; color:#111;
    }
    .btn-icon:active{ transform:translateY(1px); }
    @media(max-width:640px){ .btn-icon{ width:42px; height:42px; font-size:18px } }
  </style>

  <!-- === AUTH GUARD —É <head>: —ñ–Ω—ñ—Ç Firebase, –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–æ–ª—ñ, –ø–æ–∫–∞–∑ DOM === -->
<script>
  (async function(){
    const CFG = window.APP_CONFIG?.firebase;
	if (!CFG) {
   console.error('APP_CONFIG.firebase –≤—ñ–¥—Å—É—Ç–Ω—ñ–π. –ü–µ—Ä–µ–≤—ñ—Ä /config/config.js');
   document.documentElement.style.visibility = 'visible';
   return;
	}
	try { firebase.apps?.length ? firebase.app() : firebase.initializeApp(CFG); } catch(e){}

    const db   = firebase.firestore();
    const auth = firebase.auth();

    /* ‚úÖ –§–Ü–ö–°: –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —à–ª—è—Ö –¥–æ –ª–æ–≥—ñ–Ω–∫–∏ */
    const loginURL = '/login.html?next=' + encodeURIComponent(location.pathname + location.search);

    auth.onAuthStateChanged(async (u) => {
      if (!u) { location.replace(loginURL); return; }

      // —á–∏—Ç–∞—î–º–æ —Ä–æ–ª—å —ñ–∑ users/{uid}, –∑–∞ –ø–æ—Ç—Ä–µ–±–∏ ‚Äî fallback –¥–æ roles/{uid}
      let role = 'pending';
      try{
        const us = await db.collection('users').doc(u.uid).get();
        role = us.exists ? (us.data().role || 'pending') : 'pending';
        if (String(role).trim().toLowerCase() === 'pending') {
          const rs = await db.collection('roles').doc(u.uid).get();
          if (rs.exists && rs.data()?.role) role = String(rs.data().role);
        }
      }catch(_){}

      window.__userRole = String(role).trim().toLowerCase();

      if (String(role).trim().toLowerCase() === 'pending') {
        alert('–í–∞—à –∞–∫–∞—É–Ω—Ç –æ—á—ñ–∫—É—î –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.');
        location.replace(loginURL); return;
      }

      /* ‚úÖ –î–û–ó–í–Ü–õ –õ–ò–®–ï –î–õ–Ø security | admin */
      if (!['security','admin'].includes(String(role).trim().toLowerCase())) {
        alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø—Ä–∞–≤ –¥–ª—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏ –ø–æ–≥–æ–¥–∂–µ–Ω–Ω—è.');
        location.replace(loginURL); return;
      }

      // –ø–æ–∫–∞–∑—É—î–º–æ DOM
      document.documentElement.style.visibility = 'visible';
    });
  })();
  </script>
</head>
<body>
<header>
  <a href="/index.html">üè† –ú–∞—Ä—à—Ä—É—Ç–∏</a>
  <div style="flex:1"></div>
  <span id="hello" class="muted">–ù–µ —É–≤—ñ–π—à–ª–∏</span>
</header>

<!-- fullscreen –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä -->
<div id="reviewWrap">
  <div class="review-card">
    <div class="pad">
      <div class="title">–ü–æ–≥–æ–¥–∂–µ–Ω–Ω—è –º–∞—Ä—à—Ä—É—Ç—É</div>
      <div id="statusLine" class="muted">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è‚Ä¶</div>

      <div class="btnRow" id="secButtons" style="margin-top:8px; display:none;">
        <button id="approveBtn" class="btn good">‚úÖ –ü–æ–≥–æ–¥–∏—Ç–∏</button>
        <button id="rejectBtn"  class="btn bad">‚ùå –í—ñ–¥—Ö–∏–ª–∏—Ç–∏</button>
        <a id="openEditor" class="btn" target="_blank">üó∫ –í—ñ–¥–∫—Ä–∏—Ç–∏ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä—ñ</a>
      </div>

      <!-- Security proposal tools -->
      <div class="btnRow" id="proposalTools" style="margin-top:6px; display:none;">
        <button id="propEditToggle" class="btn warn">‚úèÔ∏è –†–µ–∂–∏–º –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó</button>
        <button id="propFromCurrent" class="btn warn" title="–°–∫–æ–ø—ñ—é–≤–∞—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç —É –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é">üìÑ –ù–∞–∫–ª–∞—Å—Ç–∏ –º–∞—Ä—à—Ä—É—Ç</button>
        <button id="propModeRoute" class="btn warn">–õ—ñ–Ω—ñ—è –º–∞—Ä—à—Ä—É—Ç—É</button>
        <button id="propModeStart" class="btn warn">–õ—ñ–Ω—ñ–π–∫–∞ (–ø–æ—á.)</button>
        <button id="propModeEnd" class="btn warn">–õ—ñ–Ω—ñ–π–∫–∞ (–∫—ñ–Ω.)</button>
        <button id="toggleRoadGridReview" class="btn">üõ£ –ü–æ–∫–∞–∑–∞—Ç–∏ —Å—ñ—Ç–∫—É –¥–æ—Ä—ñ–≥</button>
        <button id="toggleGeozonesReview" class="btn">üó∫ –ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ –≥–µ–æ–∑–æ–Ω–∏</button>
        <button id="propSave" class="btn good">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é</button>
        <button id="propClear" class="btn">üóë –û—á–∏—Å—Ç–∏—Ç–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é</button>
      </div>

      <div id="rejectWrap" style="display:none; margin-top:10px;">
        <label>–ü—Ä–∏—á–∏–Ω–∞ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è (–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ)</label>
        <textarea id="rejectComment" placeholder="–û–ø–∏—à—ñ—Ç—å, —â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–ø—Ä–∞–≤–∏—Ç–∏"></textarea>
        <div class="btnRow" style="margin-top:6px;">
          <button id="sendReject" class="btn bad">–í—ñ–¥—Ö–∏–ª–∏—Ç–∏ –∑ –∫–æ–º–µ–Ω—Ç–∞—Ä–µ–º</button>
          <button id="cancelReject" class="btn">–°–∫–∞—Å—É–≤–∞—Ç–∏</button>
        </div>
      </div>
    </div>

    <div id="map"></div>

    <!-- –ö–æ–º–ø–∞–∫—Ç–Ω—ñ —ñ–∫–æ–Ω–∫–∏ –Ω–∞ –∫–∞—Ä—Ç—ñ: —Å—Ç–∏–ª—å —ñ –ø–æ—à—É–∫ -->
    <div class="map-tools" aria-label="–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∫–∞—Ä—Ç–∏">
      <button id="btnStyleCycle" class="btn-icon" title="–ó–º—ñ–Ω–∏—Ç–∏ —Å—Ç–∏–ª—å –∫–∞—Ä—Ç–∏">üé®</button>
      <button id="btnPlaceSearch" class="btn-icon" title="–ü–æ—à—É–∫ –Ω–∞—Å–µ–ª–µ–Ω–æ–≥–æ –ø—É–Ω–∫—Ç—É">üîé</button>
    </div>

    <div class="pad">
      <div class="row">
        <div>
          <div class="chip" id="chipStatus">–°—Ç–∞—Ç—É—Å: ‚Äî</div>
          <div class="chip" id="chipDistanceTotal">–ü–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç: ‚Äî</div>
          <div class="chip proposal" id="chipProposal">–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è: ‚Äî</div>
          <div class="chip" id="chipRevision">–ü–æ–¥–∞—á–∞ ‚Ññ ‚Äî</div>
        </div>
        <div style="text-align:right">
          <div class="muted">–ú–∞—Ä—à—Ä—É—Ç: <b id="routeName">‚Äî</b></div>
          <div class="muted">–í—ñ–¥: <b id="fromLabel">‚Äî</b> ‚Üí –î–æ: <b id="toLabel">‚Äî</b></div>
        </div>
      </div>
      <div id="decisionInfo" class="muted" style="margin-top:8px;"></div>
      <div id="rejectInfo" class="muted" style="margin-top:6px;color:#b91c1c;"></div>
    </div>
  </div>
</div>

<script>
  // === Firebase (–≤–∂–µ —ñ–Ω—ñ—Ç —É head-guard) ===
  const db   = firebase.firestore();
  const auth = firebase.auth();
  async function getNormalizedRole(){
  if (window.__userRole) return String(window.__userRole).trim().toLowerCase();
  try{
    const u = auth.currentUser;
    if (!u) return 'user';
    const us = await db.collection('users').doc(u.uid).get();
    const r = us.exists ? (us.data().role || 'pending') : 'pending';
    return String(r).trim().toLowerCase();
  }catch{ return 'user'; }
}

  // --- –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç ---
  function toLonLat(p){
    if (Array.isArray(p) && p.length>=2){
      const a=Number(p[0]), b=Number(p[1]);
      return (Math.abs(a)<=90 && Math.abs(b)<=180) ? [b,a] : [a,b]; // –∞–≤—Ç–æ-–æ–±–º—ñ–Ω lat/lng
    }
    if (p && typeof p==='object'){
      const lat=Number(p.lat ?? p.latitude), lng=Number(p.lng ?? p.lon ?? p.longitude);
      if (Number.isFinite(lat) && Number.isFinite(lng)) return [lng,lat];
    }
    if (typeof p==='string'){
      const m=p.split(/[;, ]/).map(Number).filter(v=>!Number.isNaN(v));
      if (m.length>=2) return toLonLat(m);
    }
    return null;
  }
  function normalizePoints(raw){
    if (!raw) return null;
    // GeoJSON Feature/Geometry
    if (raw.type==='Feature' && raw.geometry?.type==='LineString') return normalizePoints(raw.geometry.coordinates);
    if (raw.type==='LineString' && Array.isArray(raw.coordinates))   return normalizePoints(raw.coordinates);
    if (raw.type==='FeatureCollection' && Array.isArray(raw.features)){
      const f=raw.features.find(f=>f.geometry?.type==='LineString'); if (f) return normalizePoints(f.geometry.coordinates);
    }
    // –º–∞—Å–∏–≤ —Ç–æ—á–æ–∫
    if (Array.isArray(raw)){
      const out=[]; for (const it of raw){ const pt=toLonLat(it); if (pt) out.push(pt); }
      return out.length>=2 ? out : null;
    }
    return null;
  }

  // === Query params ===
  const qs  = new URLSearchParams(location.search);
  const rid = qs.get('rid');

  // === Mapbox init ===
  mapboxgl.accessToken = (window.APP_CONFIG && window.APP_CONFIG.mapboxToken) || '';
  const map = new mapboxgl.Map({
    container:'map',
    style:'mapbox://styles/mapbox/streets-v12',
    center:[28.468,49.234],
    zoom:11
  });
  // –£–∫—Ä–∞—ó–Ω—Å—å–∫—ñ –ø—ñ–¥–ø–∏—Å–∏ –±–∞–∑–æ–≤–∏—Ö —à–∞—Ä—ñ–≤ (—è–∫ –Ω–∞ –≥–æ–ª–æ–≤–Ω—ñ–π)
  function applyUkrainianLabels(){
    try{
      const style = map.getStyle(); if (!style || !style.layers) return;
      const ukTextExpr = ['coalesce',['get','name_uk'],['get','name:uk'],['get','name_ua'],['get','name:ua'],['get','name_local'],['get','name']];
      style.layers.forEach(l => {
        if (l.type !== 'symbol') return;
        const has = map.getLayoutProperty(l.id, 'text-field') !== undefined;
        if (has){ try{ map.setLayoutProperty(l.id, 'text-field', ukTextExpr); }catch(_){ } }
      });
    }catch(_){ }
  }
  map.on('style.load', applyUkrainianLabels);
  // –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∏–ª—å —Ç–∞ —Å–ø–∏—Å–æ–∫ —Å—Ç–∏–ª—ñ–≤ (—Ü–∏–∫–ª—ñ—á–Ω–µ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è)
  const STYLE_KEY = 'REVIEW_STYLE';
  const STYLES = [
    'mapbox://styles/mapbox/streets-v12',
    'mapbox://styles/mapbox/satellite-v9',
    'mapbox://styles/mapbox/satellite-streets-v12',
    'mapbox://styles/mapbox/outdoors-v12'
  ];
  let currentStyle = (()=>{
    try{ const v = localStorage.getItem(STYLE_KEY); return v && STYLES.includes(v) ? v : STYLES[0]; }catch(_){ return STYLES[0]; }
  })();
  try{ map.setStyle(currentStyle); }catch(_){ }

  // ==== –ü–µ—Ä–µ–º–∏–∫–∞—á —Å—Ç–∏–ª—é –∫–∞—Ä—Ç–∏ (—è–∫ –Ω–∞ –≥–æ–ª–æ–≤–Ω—ñ–π) ====
  function setMapStyle(val){
    try{
      if (!val || val === currentStyle) return;
      currentStyle = val;
      try{ localStorage.setItem(STYLE_KEY, currentStyle); }catch(_){ }
      map.setStyle(currentStyle);
    }catch(_){ }
  }
  // –¶–∏–∫–ª—ñ—á–Ω–µ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è —Å—Ç–∏–ª—é –ø–æ –∫–ª—ñ–∫—É –Ω–∞ üé®
  (function initStyleButton(){
    const btn = document.getElementById('btnStyleCycle');
    if (!btn) return;
    btn.addEventListener('click', ()=>{
      const i = STYLES.indexOf(currentStyle);
      const next = STYLES[(i>=0 ? i : 0) + 1 >= STYLES.length ? 0 : ((i>=0?i:0)+1)];
      setMapStyle(next);
    });
  })();

  // ==== –ü–æ—à—É–∫ –Ω–∞—Å–µ–ª–µ–Ω–æ–≥–æ –ø—É–Ω–∫—Ç—É —á–µ—Ä–µ–∑ Mapbox Geocoding (—è–∫ –Ω–∞ –≥–æ–ª–æ–≤–Ω—ñ–π) ====
  let __placeSearchTimer = null;
  let __placeResults = [];
  async function suggestPlaces(q){
    try{
      const token = mapboxgl.accessToken || '';
      if (!token) return [];
      const url = new URL('https://api.mapbox.com/geocoding/v5/mapbox.places/' + encodeURIComponent(q) + '.json');
      url.searchParams.set('access_token', token);
      url.searchParams.set('autocomplete', 'true');
      url.searchParams.set('language', 'uk');
      url.searchParams.set('limit', '7');
      url.searchParams.set('types', 'place,locality,neighborhood');
      url.searchParams.set('country', 'ua');
      try{
        const c = map.getCenter();
        url.searchParams.set('proximity', c.lng + ',' + c.lat);
      }catch(_){ }
      const res = await fetch(url.toString());
      const data = await res.json();
      const feats = Array.isArray(data?.features) ? data.features : [];
      return feats.map(f => ({ id:f.id, name:f.text_uk || f.text || '', full:f.place_name_uk || f.place_name || '', center:f.center }));
    }catch(_){ return []; }
  }
  // –ú—ñ–Ω—ñ–º–∞–ª—ñ—Å—Ç–∏—á–Ω–∏–π –ø–æ—à—É–∫ —á–µ—Ä–µ–∑ prompt (—â–æ–± –Ω–µ –∑–∞–π–º–∞—Ç–∏ –º—ñ—Å—Ü–µ –≤ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ñ)
  (function initSearchButton(){
    const btn = document.getElementById('btnPlaceSearch');
    if (!btn) return;
    btn.addEventListener('click', async ()=>{
      const q = (window.prompt('–ü–æ—à—É–∫ –Ω–∞—Å–µ–ª–µ–Ω–æ–≥–æ –ø—É–Ω–∫—Ç—É:') || '').trim();
      if (!q) return;
      const rows = await suggestPlaces(q);
      __placeResults = rows;
      const target = rows && rows[0];
      if (target && Array.isArray(target.center)){
        try{ map.flyTo({ center: target.center, zoom: Math.max(map.getZoom()||0, 11), essential:true }); }catch(_){ }
      } else {
        alert('–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ');
      }
    });
  })();
  
  // =============== PROPOSAL (Mapbox Draw) ===============
  let draw = null;
  let proposalEditOn = false;
  let proposalMode = 'route'; // 'route' | 'start' | 'end'
  const propIds = { route: null, start: null, end: null };
  function ensureDrawOnce(){
    if (draw) return;
    try{
      draw = new MapboxDraw({
        displayControlsDefault: false,
        modes: MapboxDraw.modes,
        styles: [
          // vertices
          {
            id: 'gl-draw-point-inactive', type:'circle', filter:['all',['==','$type','Point'],['!=','meta','midpoint']],
            paint:{ 'circle-radius':5, 'circle-color':'#f59e0b', 'circle-stroke-width':2, 'circle-stroke-color':'#fff' }
          },
          {
            id: 'gl-draw-point-active', type:'circle', filter:['all',['==','$type','Point'],['==','active','true']],
            paint:{ 'circle-radius':6, 'circle-color':'#f59e0b', 'circle-stroke-width':2, 'circle-stroke-color':'#111' }
          },
          // üîï –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è ¬´—Å–µ—Ä–µ–¥–Ω—ñ—Ö —Ç–æ—á–æ–∫¬ª, —â–æ–± –Ω–µ –∑–∞—Å–º—ñ—á—É–≤–∞—Ç–∏ –µ–∫—Ä–∞–Ω
          // raw line from Draw ‚Äî —Ä–æ–±–∏–º–æ –ø—Ä–æ–∑–æ—Ä–∏–º, —â–æ–± –Ω–µ –±–∞—á–∏—Ç–∏ –Ω–µ‚Äë—Å–Ω–∞–ø–Ω—É—Ç—ñ –ø—Ä—è–º—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
          {
            id: 'gl-draw-line-inactive', type:'line', filter:['all',['==','$type','LineString'],['!=','active','true']],
            paint:{ 'line-color':'#f59e0b','line-width':3, 'line-opacity':0 }
          },
          { id: 'gl-draw-line-active', type:'line', filter:['all',['==','$type','LineString'],['==','active','true']], paint:{ 'line-color':'#f59e0b','line-width':4, 'line-opacity':0 } },
          // midpoints
          { id:'gl-draw-polygon-and-line-vertex-halo-active', type:'circle', filter:['all',['==','meta','vertex'],['==','$type','Point']], paint:{ 'circle-radius':8,'circle-color':'#fff' } },
          { id:'gl-draw-polygon-and-line-vertex-active', type:'circle', filter:['all',['==','meta','vertex'],['==','$type','Point']], paint:{ 'circle-radius':5,'circle-color':'#f59e0b' } },
        ]
      });
      map.addControl(draw, 'top-right');
      map.on('draw.create', onDrawChanged);
      map.on('draw.update', onDrawChanged);
      map.on('draw.delete', onDrawChanged);
    }catch(_){ }
  }
  function onDrawChanged(){
    updateProposalPreview();
  }
  function resetProposalEditUI(){
    const btns = ['propEditToggle','propModeRoute','propModeStart','propModeEnd'];
    btns.forEach(id=>{ try{ document.getElementById(id).classList.remove('active'); }catch(_){} });
    try{ document.getElementById('propEditToggle').classList.toggle('active', proposalEditOn); }catch(_){ }
    try{
      document.getElementById('propModeRoute').classList.toggle('active', proposalMode==='route');
      document.getElementById('propModeStart').classList.toggle('active', proposalMode==='start');
      document.getElementById('propModeEnd').classList.toggle('active', proposalMode==='end');
    }catch(_){ }
    // –ü–µ—Ä–µ–º–∫–Ω–µ–º–æ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —É Draw
    try{
      if (!draw) return;
      if (!proposalEditOn){ draw.changeMode('simple_select', {}); return; }
      // –ü—Ä–∏–º—É—Å–æ–≤–æ –∞–∫—Ç–∏–≤—É—î–º–æ –ø–æ—Ç—Ä—ñ–±–Ω—É –ª—ñ–Ω—ñ—é, —â–æ–± –æ–¥—Ä–∞–∑—É –∑ º—è–≤–∏–ª–∏—Å—è –≤–µ—Ä—à–∏–Ω–∏
      ensureFeatureForKind(proposalMode);
    }catch(_){ }
  }

  function ensureFeatureForKind(kind){
    ensureDrawOnce();
    try{
      // –ù–µ —Å—Ç–≤–æ—Ä—é—î–º–æ –ø—Ä–∏–º—É—Å–æ–≤–æ –∂–æ–¥–Ω–∏—Ö —Ç–æ—á–æ–∫ ‚Äî –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á —Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä—à—É —Ç–æ—á–∫—É —Å–∞–º.
      // –ê–ª–µ –æ–±–æ–≤ º—è–∑–∫–æ–≤–æ –∞–∫—Ç–∏–≤—É—î–º–æ direct_select –¥–ª—è —ñ—Å–Ω—É—é—á–æ—ó –ª—ñ–Ω—ñ—ó, 
      // —ñ —Ä–æ–±–∏–º–æ —Ü–µ —á–µ—Ä–µ–∑ –∫–æ—Ä–æ—Ç–∫–µ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è —É simple_select –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ.
      let id = propIds[kind];
      if (!id){
        try{
          const all = draw.getAll();
          const feat = all.features?.find(f => f.geometry?.type==='LineString' && f.properties?.kind===kind);
          if (feat) id = feat.id;
        }catch(_){ }
      }
      if (id){
        try{ draw.changeMode('simple_select'); }catch(_){}
        setTimeout(()=>{ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }, 0);
      }
    }catch(_){ }
  }
  function ensureProposalLayers(){
    const addIf = (id, src) => { try{ if (!map.getSource(id)) map.addSource(id, src); }catch(_){ } };
    addIf('proposal-route-snap', { type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    addIf('proposal-start-src',  { type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    addIf('proposal-end-src',    { type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    const beforeId = (map.getLayer('gl-draw-line-inactive') ? 'gl-draw-line-inactive' : undefined);
    const addLayer = (def, before) => { try{ if (!map.getLayer(def.id)) map.addLayer(def, before); }catch(_){ } };
    // –ö–ª–∞–¥–µ–º–æ snapped/–ª—ñ–Ω—ñ–π–∫–∏ –ü–Ü–î —à–∞—Ä–∏ Draw, —â–æ–± –≤–µ—Ä—à–∏–Ω–∏ –±—É–ª–∏ –≤–∏–¥–∏–º—ñ —ñ –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω—ñ
    addLayer({ id:'proposal-route-snap', type:'line', source:'proposal-route-snap', paint:{ 'line-color':'#facc15','line-width':5 } }, beforeId);
    addLayer({ id:'proposal-start', type:'line', source:'proposal-start-src', paint:{ 'line-color':'#2563eb','line-width':3,'line-dasharray':[1,2] } }, beforeId);
    addLayer({ id:'proposal-end',   type:'line', source:'proposal-end-src',   paint:{ 'line-color':'#f59e0b','line-width':3,'line-dasharray':[1,2] } }, beforeId);
  }
  // –ü—ñ—Å–ª—è –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è —Å—Ç–∏–ª—é –∫–∞—Ä—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ —à–∞—Ä–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó
  try{
    map.on('style.load', async () => {
      try{ applyUkrainianLabels(); }catch(_){ }
      // –ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è
      try{ ensureProposalLayers(); }catch(_){ }
      try{
        if (LAST_ROUTE_DOC && LAST_ROUTE_DOC.proposal){
          loadProposalToDraw(LAST_ROUTE_DOC.proposal);
        } else {
          setProposalSources([],[],[]);
        }
      }catch(_){ }
      // –û—Å–Ω–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç + –ª—ñ–Ω—ñ–π–∫–∏ + —Ä—É—á–Ω—ñ —Å–µ–≥–º–µ–Ω—Ç–∏
      try{
        if (Array.isArray(CURRENT_ROUTE_POINTS) && CURRENT_ROUTE_POINTS.length>=2){
          await drawSnappedRoute(CURRENT_ROUTE_POINTS);
          setSEMarkers(CURRENT_ROUTE_POINTS);
        }
      }catch(_){ }
      try{ drawRulersFromArrays(CURRENT_START_RULER, CURRENT_END_RULER); }catch(_){ }
      try{ if (LAST_ROUTE_DOC) drawManualSegments(LAST_ROUTE_DOC); }catch(_){ }
      // –î–æ—Ä–æ–∂–Ω—è —Å—ñ—Ç–∫–∞ —Ç–∞ –≥–µ–æ–∑–æ–Ω–∏
      try{ addRoadGridLayer(); setRoadGridVisibility(roadGridVisible); }catch(_){ }
      try{ await loadTilesetsConfigOnce(); addTilesets(); ensureHighlightLayers(); updateHighlightsForRoute(LAST_ROUTE_DOC||{}); updateGeozonesToggleLabel(); setGeozonesVisibility(__geozonesVisible); }catch(_){ }
    });
  }catch(_){ }
  function setProposalSources(routeCoords, startCoords, endCoords){
    ensureProposalLayers();
    try{
      const fc = c => ({ type:'FeatureCollection', features: c && c.length>=2 ? [{ type:'Feature', geometry:{ type:'LineString', coordinates:c }}] : [] });
      map.getSource('proposal-route-snap')?.setData(fc(routeCoords));
      map.getSource('proposal-start-src')?.setData(fc(startCoords));
      map.getSource('proposal-end-src')?.setData(fc(endCoords));
    }catch(_){ }
  }
  function getDrawCoordsBy(kind){
    try{
      if (!draw) return null;
      const all = draw.getAll();
      if (!all || !all.features) return null;
      // we tag features by property kind
      const feat = all.features.find(f => f.geometry?.type==='LineString' && (f.properties?.kind === kind));
      return feat ? (feat.geometry.coordinates||null) : null;
    }catch(_){ return null; }
  }
  function upsertDrawLine(kind, coords){
    try{
      if (!draw) return;
      const all = draw.getAll();
      let feat = all.features.find(f => f.geometry?.type==='LineString' && (f.properties?.kind === kind));
      // –ë–µ–∑–ø–µ—á–Ω–∏–π upsert: —è–∫—â–æ —ñ—Å–Ω—É—é—á—É –≥–µ–æ–º–µ—Ç—Ä—ñ—é –Ω–µ –º–æ–∂–µ–º–æ –æ–Ω–æ–≤–∏—Ç–∏ –Ω–∞–ø—Ä—è–º—É ‚Äî –ø–µ—Ä–µ–≤—Å—Ç–∞–≤–∏–º–æ
      if (feat){
        try { draw.setFeatureProperty(feat.id, 'kind', kind); } catch(_){ }
        try { draw.delete(feat.id); } catch(_){ }
        feat = null;
      }
      if (!feat){
        const id = draw.add({ type:'Feature', properties:{ kind }, geometry:{ type:'LineString', coordinates: coords||[] } });
        propIds[kind] = Array.isArray(id) ? id[0] : id;
      }
    }catch(_){ }
  }
  async function updateProposalPreview(){
    try{
      const route = getDrawCoordsBy('route') || [];
      const start = getDrawCoordsBy('start') || [];
      const end   = getDrawCoordsBy('end')   || [];
      let meters = 0;
      // snapped route distance via Directions, if we have 2+
      let snapped = [];
      if (route.length >= 2){
        const chunks = splitIntoChunks(route, 20);
        for (let i=0;i<chunks.length;i++){
          const coordsStr = chunks[i].map(p=>p.join(',')).join(';');
          const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordsStr}?geometries=geojson&overview=full&continue_straight=true&access_token=${mapboxgl.accessToken}`;
          try{
            const r = await fetch(url);
            const j = await r.json();
            const geom = j?.routes?.[0]?.geometry;
            if (geom?.coordinates){ snapped = snapped.concat(geom.coordinates); meters += (j?.routes?.[0]?.distance || 0); }
          }catch(_){ }
        }
      }
      // rulers
      meters += pathLengthMeters(start) + pathLengthMeters(end);
      setProposalSources(snapped.length ? snapped : route, start, end);
      const km = meters/1000;
      const chip = document.getElementById('chipProposal');
      if (chip) chip.textContent = '–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è: ' + (isFinite(km) && km>0 ? km.toFixed(2)+' –∫–º' : '‚Äî');
    }catch(_){ }
  }
  function loadProposalToDraw(proposal){
    ensureDrawOnce();
    try{ draw.deleteAll(); }catch(_){ }
    if (!proposal || typeof proposal !== 'object') { updateProposalPreview(); return; }
    const route = normalizePoints(proposal.points) || [];
    const start = normalizePoints(proposal.startRuler) || [];
    const end   = normalizePoints(proposal.endRuler) || [];
    if (route.length) upsertDrawLine('route', route);
    if (start.length) upsertDrawLine('start', start);
    if (end.length)   upsertDrawLine('end',   end);
    updateProposalPreview();
  }
  function proposalObjFromDraw(){
    const toObj = coords => (coords||[]).map(([lng,lat]) => ({ lng, lat }));
    const route = getDrawCoordsBy('route') || [];
    const start = getDrawCoordsBy('start') || [];
    const end   = getDrawCoordsBy('end')   || [];
    const o = { points: toObj(route), startRuler: toObj(start), endRuler: toObj(end) };
    return o;
  }
  async function saveProposal(){
    const role = await getNormalizedRole();
    if (!['security','admin'].includes(role)) { alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø—Ä–∞–≤.'); return; }
    const user = auth.currentUser;
    const base = proposalObjFromDraw();
    // compute distance via preview chip if exists; otherwise compute quickly
    let distance_km = 0;
    try{
      const txt = (document.getElementById('chipProposal')?.textContent||'').replace(/[^0-9.,]/g,'').replace(',','.');
      const val = parseFloat(txt); if (isFinite(val)) distance_km = val;
    }catch(_){ }
    const payload = {
      proposal: {
        ...base,
        distance_km,
        createdAt: new Date().toISOString(),
        createdByUid: user?.uid || null,
        createdByEmail: user?.email || null
      },
      updatedAt: new Date().toISOString()
    };
    try{
      await db.collection('routes').doc(rid).set(payload, { merge:true });
      alert('‚úÖ –ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—é –∑–±–µ—Ä–µ–∂–µ–Ω–æ');
    }catch(e){ alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é: ' + (e?.message||e)); }
  }
  async function clearProposal(){
    const role = await getNormalizedRole();
    if (!['security','admin'].includes(role)) { alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø—Ä–∞–≤.'); return; }
    if (!confirm('–û—á–∏—Å—Ç–∏—Ç–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é?')) return;
    try{
      await db.collection('routes').doc(rid).set({ proposal: firebase.firestore.FieldValue.delete(), updatedAt: new Date().toISOString() }, { merge:true });
      try{ draw && draw.deleteAll(); }catch(_){ }
      setProposalSources([],[],[]);
      const chip = document.getElementById('chipProposal'); if (chip) chip.textContent = '–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è: ‚Äî';
      alert('üßπ –ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—é –æ—á–∏—â–µ–Ω–æ');
    }catch(e){ alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—á–∏—Å—Ç–∏—Ç–∏: ' + (e?.message||e)); }
  }

  /* ---------- layout helper: –∫–∞—Ä—Ç–∞ –Ω–∞ –≤–µ—Å—å –µ–∫—Ä–∞–Ω –ø—ñ–¥ —Ö–µ–¥–µ—Ä–æ–º ---------- */
  const topbarEl = document.querySelector('header');
  function updateLayoutHeights(){
    const h = (topbarEl?.offsetHeight || 56);
    document.documentElement.style.setProperty('--nav-real', h + 'px');
    try{ map.resize(); }catch{}
  }
  window.addEventListener('resize', updateLayoutHeights);
  map.on('load', updateLayoutHeights);
  // –î–æ–∑–≤–æ–ª–∏–º–æ –∫–æ–º—Ñ–æ—Ä—Ç–Ω–∏–π –ø–∞–Ω ‚Äî —Ñ—ñ–∫—Å—É—î–º–æ —Å—Ç–∞–Ω –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –∫–∞—Ä—Ç–∏,
  // —â–æ–± –Ω–µ –¥–æ–¥–∞–≤–∞—Ç–∏ —Ç–æ—á–∫—É –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ñ drag
  let __isMapDragging = false;
  let __lastDragEndAt = 0;
  map.on('dragstart', ()=>{ __isMapDragging = true; });
  map.on('dragend',   ()=>{ __isMapDragging = false; __lastDragEndAt = Date.now(); });

  // ===== –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–µ –º–µ–Ω—é –ø–æ –ø—Ä–∞–≤–æ–º—É –∫–ª—ñ–∫—É –Ω–∞ –≤–µ—Ä—à–∏–Ω—ñ =====
  const ctxMenu = document.createElement('div');
  ctxMenu.className = 'ctx-menu';
  ctxMenu.innerHTML = [
    '<button id="ctx-add-before">‚ûï –î–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–¥</button>',
    '<button id="ctx-add-after">‚ûï –î–æ–¥–∞—Ç–∏ –ø—ñ—Å–ª—è</button>',
    '<button id="ctx-del">üóë –í–∏–¥–∞–ª–∏—Ç–∏ —Ç–æ—á–∫—É</button>'
  ].join('');
  document.body.appendChild(ctxMenu);
  let __ctx = null; // { parentId, kind, index }
  function hideCtx(){ ctxMenu.style.display='none'; __ctx=null; }
  function showCtx(x,y,ctx){ __ctx=ctx; ctxMenu.style.display='block'; ctxMenu.style.left=Math.round(x)+"px"; ctxMenu.style.top=Math.round(y)+"px"; }
  document.addEventListener('click', (e)=>{ if (!ctxMenu.contains(e.target)) hideCtx(); });
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') hideCtx(); });
  let __pendingInsert = null; // { kind, index, dir }
  function setPendingInsert(state){
    __pendingInsert = state; hideCtx();
    try{ document.body.classList.toggle('pending-insert', !!state); }catch(_){ }
  }
  function replaceLineFeature(parentId, kind, coords){
    try{ draw.delete(parentId); }catch(_){ }
    const newId = draw.add({ type:'Feature', properties:{ kind }, geometry:{ type:'LineString', coordinates: coords } });
    const id = Array.isArray(newId) ? newId[0] : newId;
    if (kind && propIds && propIds[kind]===parentId) propIds[kind] = id;
    try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ }
    updateProposalPreview();
  }
  function midpoint(a,b){ return [ (a[0]+b[0])/2, (a[1]+b[1])/2 ]; }
  function suggestInsertCoord(coords, index, dir, clickLL){
    // dir: 'before' | 'after'
    // 1) —è–∫—â–æ —î –∫–ª—ñ–∫–æ–≤—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—î–º–æ —ó—Ö
    if (Array.isArray(clickLL) && clickLL.length>=2) return clickLL;
    // 2) —ñ–Ω–∞–∫—à–µ ‚Äî —Å–µ—Ä–µ–¥–∏–Ω–∞ –º—ñ–∂ —Å—É—Å—ñ–¥–Ω—ñ–º–∏ –≤–µ—Ä—à–∏–Ω–∞–º–∏
    if (dir==='after'){
      if (index < coords.length-1) return midpoint(coords[index], coords[index+1]);
      if (coords.length>=2) return midpoint(coords[coords.length-2], coords[coords.length-1]);
      return coords[index] || clickLL; // —Ñ–æ–ª–±–µ–∫
    } else {
      if (index > 0) return midpoint(coords[index-1], coords[index]);
      if (coords.length>=2) return midpoint(coords[0], coords[1]);
      return coords[index] || clickLL;
    }
  }
  ctxMenu.querySelector('#ctx-add-before').addEventListener('click', ()=>{
    if (!__ctx) return; const { kind, index } = __ctx; setPendingInsert({ kind, index, dir:'before' });
  });
  ctxMenu.querySelector('#ctx-add-after').addEventListener('click', ()=>{
    if (!__ctx) return; const { kind, index } = __ctx; setPendingInsert({ kind, index, dir:'after' });
  });
  ctxMenu.querySelector('#ctx-del').addEventListener('click', ()=>{
    if (!__ctx) return; const { parentId, kind, index } = __ctx; hideCtx();
    try{
      ensureDrawOnce();
      const feat = draw.get(parentId);
      if (!feat || feat.geometry?.type!=='LineString') return;
      const coords = (feat.geometry.coordinates||[]).slice();
      if (!coords.length) return;
      const i = Math.max(0, Math.min(index, coords.length-1));
      coords.splice(i, 1);
      replaceLineFeature(parentId, (kind || feat.properties?.kind), coords);
    }catch(_){ }
  });

  map.on('contextmenu', (ev)=>{
    hideCtx();
    if (!proposalEditOn) return; // –ª–∏—à–µ –≤ —Ä–µ–∂–∏–º—ñ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è
    try{
      const feats = map.queryRenderedFeatures(ev.point);
      // —à—É–∫–∞—î–º–æ vertex –≤—ñ–¥ Mapbox Draw
      const hit = (feats||[]).find(f=> f.properties && f.properties.meta==='vertex' && (f.layer?.id||'').startsWith('gl-draw'));
      if (!hit) return;
      const parentId = hit.properties.parent || hit.properties.featureId || hit.properties.id;
      if (!parentId) return;
      const feat = draw.get(parentId);
      if (!feat || feat.geometry?.type!=='LineString') return;
      const kind = feat.properties?.kind || null;
      // coord_path like "0.12" -> take last number as vertex index
      const cp = String(hit.properties.coord_path||'');
      const parts = cp.split('.');
      const index = Number(parts[parts.length-1]);
      if (!Number.isFinite(index)) return;

      // –ø–æ–∫–∞–∑—É—î–º–æ –º–µ–Ω—é –±—ñ–ª—è –∫—É—Ä—Å–æ—Ä–∞
      const { clientX, clientY } = ev.originalEvent || ev.point || {};
      const x = (ev.originalEvent?.clientX ?? clientX ?? 0);
      const y = (ev.originalEvent?.clientY ?? clientY ?? 0);
      showCtx(x,y,{ parentId, kind, index });
      ev.preventDefault();
    }catch(_){ }
  });

  // –û–±—á–∏—Å–ª–µ–Ω–Ω—è –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ –¥–æ –∫–ª—ñ–∫—É —É –ø—ñ–∫—Å–µ–ª—è—Ö
  function nearestSegmentPx(coords, point){
    if (!Array.isArray(coords) || coords.length<2) return { idx:-1, distPx:Infinity };
    const p = map.project(point);
    let best = { idx:-1, distPx:Infinity };
    for (let i=0;i<coords.length-1;i++){
      const a = map.project(coords[i]);
      const b = map.project(coords[i+1]);
      const abx = b.x - a.x, aby = b.y - a.y;
      const apx = p.x - a.x, apy = p.y - a.y;
      const ab2 = abx*abx + aby*aby || 1;
      let t = (apx*abx + apy*aby) / ab2; t = Math.max(0, Math.min(1, t));
      const projx = a.x + t*abx, projy = a.y + t*aby;
      const dx = p.x - projx, dy = p.y - projy;
      const d2 = dx*dx + dy*dy;
      if (d2 < best.distPx) best = { idx:i, distPx: Math.sqrt(d2) };
    }
    return best;
  }
  function pxDist(a, b){
    const pa = map.project(a), pb = map.project(b);
    const dx = pa.x - pb.x, dy = pa.y - pb.y; return Math.sqrt(dx*dx + dy*dy);
  }
  function mergeNearDuplicates(coords, px=3){
    if (!Array.isArray(coords) || coords.length<2) return coords||[];
    const out=[coords[0]];
    for (let i=1;i<coords.length;i++){
      const prev = out[out.length-1];
      if (pxDist(prev, coords[i]) > px) out.push(coords[i]);
      else out[out.length-1] = coords[i]; // replace with latest
    }
    return out;
  }

  /* ---------- helpers ---------- */
  function fromObjPoints(arr){ return (arr||[]).map(p => Array.isArray(p) ? p : [p.lng, p.lat]); }
  function chip(id,t){ const el=document.getElementById(id); if(el) el.textContent = t; }
  function fmtStatus(s){ return ({draft:'–ß–µ—Ä–Ω–µ—Ç–∫–∞',pending:'–û—á—ñ–∫—É—î',approved:'–ü–æ–≥–æ–¥–∂–µ–Ω–æ',rejected:'–í—ñ–¥—Ö–∏–ª–µ–Ω–æ'})[s] || s || '‚Äî'; }

  // —Å–ø–ª—ñ—Ç –Ω–∞ —à–º–∞—Ç–∫–∏ (Mapbox Directions ‚â§25 –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç/–∑–∞–ø–∏—Ç; –±–µ—Ä–µ–º–æ 20 –∑ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è–º)
  function splitIntoChunks(arr, chunkSize){
    const out=[]; for(let i=0;i<arr.length-1;i+=chunkSize-1){
      const chunk=arr.slice(i,i+chunkSize); if(chunk.length>=2) out.push(chunk);
    } return out;
  }

  let routeLayers = [];
  // –∑–±–µ—Ä–µ–∂–µ–º–æ –≤–∏—Ö—ñ–¥–Ω—ñ —Ç–æ—á–∫–∏ –º–∞—Ä—à—Ä—É—Ç—É —Ç–∞ –ª—ñ–Ω—ñ–π–æ–∫ (—è–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω—ñ –∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞), —â–æ–± —à–≤–∏–¥–∫–æ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é-–∫–æ–ø—ñ—é
  let CURRENT_ROUTE_POINTS = [];
  let CURRENT_START_RULER = [];
  let CURRENT_END_RULER   = [];
  // –æ—Å—Ç–∞–Ω–Ω—ñ–π –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π –¥–æ–∫—É–º–µ–Ω—Ç –º–∞—Ä—à—Ä—É—Ç—É ‚Äî –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —à–∞—Ä—ñ–≤ –ø—ñ—Å–ª—è –∑–º—ñ–Ω–∏ —Å—Ç–∏–ª—é
  let LAST_ROUTE_DOC = null;
  function clearRouteLayers(){
    routeLayers.forEach(id=>{
      try{ if(map.getLayer(id)) map.removeLayer(id); }catch{}
      try{ if(map.getSource(id)) map.removeSource(id); }catch{}
    });
    routeLayers = [];
  }

  // snapped-to-road —Ä–µ–Ω–¥–µ—Ä—ñ–Ω–≥ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É
  async function drawSnappedRoute(points){
    clearRouteLayers();
    if(!Array.isArray(points) || points.length<2){
      return 0;
    }

    const chunks = splitIntoChunks(points, 20);
    let totalMeters = 0;

    // bounds
    let bMinLng=+Infinity, bMinLat=+Infinity, bMaxLng=-Infinity, bMaxLat=-Infinity;
    const grow = ([lng,lat])=>{
      if(lng<bMinLng) bMinLng=lng; if(lat<bMinLat) bMinLat=lat;
      if(lng>bMaxLng) bMaxLng=lng; if(lat>bMaxLat) bMaxLat=lat;
    };

    for(let i=0;i<chunks.length;i++){
      const coordsStr = chunks[i].map(p=>p.join(',')).join(';');
      const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordsStr}?geometries=geojson&overview=full&continue_straight=true&access_token=${mapboxgl.accessToken}`;
      try{
        const res = await fetch(url);
        if (!res.ok) throw new Error('Directions HTTP ' + res.status);
        const data = await res.json();
         const route = data?.routes?.[0];
         if(!route) continue;

        totalMeters += (route.distance||0);
        const geom = route.geometry;

        const srcId = `rev-route-${i}`;
        map.addSource(srcId, { type:'geojson', data:{ type:'Feature', geometry:geom }});
        map.addLayer({
          id: srcId, type:'line', source:srcId,
          layout:{ 'line-cap':'round','line-join':'round' },
          paint:{ 'line-color': '#ff2d2d', 'line-width': 5 }
        });
        routeLayers.push(srcId);

        (geom.coordinates||[]).forEach(grow);
      }catch(e){ console.warn('Directions error', e); }
    }

    if(isFinite(bMinLng)){
      map.fitBounds([[bMinLng,bMinLat],[bMaxLng,bMaxLat]], { padding: 40, maxZoom: 14 });
    }

    return totalMeters;
  }

  // dashed rulers
  function drawRulers(d){
    ['ruler-start','ruler-end','ruler-start-src','ruler-end-src'].forEach(id=>{
      try{ if(map.getLayer(id)) map.removeLayer(id); }catch{}
      try{ if(map.getSource(id)) map.removeSource(id); }catch{}
    });

    const rs = fromObjPoints(d.startRuler||[]);
    if (rs.length >= 2){
      map.addSource('ruler-start-src',{type:'geojson', data:{ type:'Feature', geometry:{ type:'LineString', coordinates: rs } }});
      map.addLayer({ id:'ruler-start', type:'line', source:'ruler-start-src',
        paint:{ 'line-color':'#0ea5e9','line-width':3,'line-dasharray':[1,2]}});
    }
    const re = fromObjPoints(d.endRuler||[]);
    if (re.length >= 2){
      map.addSource('ruler-end-src',{type:'geojson', data:{ type:'Feature', geometry:{ type:'LineString', coordinates: re } }});
      map.addLayer({ id:'ruler-end', type:'line', source:'ruler-end-src',
        paint:{ 'line-color':'#22c55e','line-width':3,'line-dasharray':[1,2]}});
    }
  }
  // dashed rulers —ñ–∑ –≤–∂–µ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –º–∞—Å–∏–≤—ñ–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–¥–ª—è style.load)
  function drawRulersFromArrays(rs, re){
    ['ruler-start','ruler-end','ruler-start-src','ruler-end-src'].forEach(id=>{
      try{ if(map.getLayer(id)) map.removeLayer(id); }catch{}
      try{ if(map.getSource(id)) map.removeSource(id); }catch{}
    });
    try{
      if (Array.isArray(rs) && rs.length>=2){
        map.addSource('ruler-start-src',{type:'geojson', data:{ type:'Feature', geometry:{ type:'LineString', coordinates: rs } }});
        map.addLayer({ id:'ruler-start', type:'line', source:'ruler-start-src',
          paint:{ 'line-color':'#0ea5e9','line-width':3,'line-dasharray':[1,2]}});
      }
      if (Array.isArray(re) && re.length>=2){
        map.addSource('ruler-end-src',{type:'geojson', data:{ type:'Feature', geometry:{ type:'LineString', coordinates: re } }});
        map.addLayer({ id:'ruler-end', type:'line', source:'ruler-end-src',
          paint:{ 'line-color':'#22c55e','line-width':3,'line-dasharray':[1,2]}});
      }
    }catch(_){ }
  }
  /* ===== –î–æ—Ä–æ–∂–Ω—è —Å—ñ—Ç–∫–∞ —è–∫ –Ω–∞ –≥–æ–ª–æ–≤–Ω—ñ–π ===== */
  let roadGridVisible = true;
  const ROAD_SRC_ID = 'road-grid-src';
  const ROAD_LAYER_ID = 'road-grid';
  function addRoadGridLayer(){
    try{
      if (!map.getSource(ROAD_SRC_ID)){
        map.addSource(ROAD_SRC_ID, { type:'vector', url:'mapbox://mapbox.mapbox-streets-v8' });
      }
      if (!map.getLayer(ROAD_LAYER_ID)){
        map.addLayer({
          id: ROAD_LAYER_ID,
          type: 'line',
          source: ROAD_SRC_ID,
          'source-layer': 'road',
          filter: ['in', ['get','class'], ['literal', ['motorway','trunk','primary','secondary','tertiary','street','street_limited','service','link','track']]],
          layout: { 'line-join':'round','line-cap':'round','visibility': roadGridVisible ? 'visible':'none' },
          paint: {
            'line-color':'#1d4ed8',
            'line-opacity': ['interpolate',['linear'],['zoom'], 0,0, 9.5,0, 10,0.25, 12,0.4, 14,0.6, 16,0.75],
            'line-width': ['interpolate',['linear'],['zoom'], 5,0.22, 10,0.35, 12,0.55, 14,0.8]
          }
        });
      }
      // –¢—Ä–∏–º–∞—Ç–∏ –Ω–∏–∂—á–µ –Ω–∞—à–∏—Ö –º–∞—Ä—à—Ä—É—Ç—ñ–≤/–ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó
      try{
        const beforeId = map.getLayer('rev-route-0') ? 'rev-route-0' : (map.getLayer('proposal-route-snap') ? 'proposal-route-snap' : undefined);
        if (beforeId) map.moveLayer(ROAD_LAYER_ID, beforeId);
      }catch(_){ }
      updateRoadGridToggleLabel();
    }catch(e){ console.warn('road grid error', e); }
  }
  function setRoadGridVisibility(v){
    roadGridVisible = !!v;
    try{ if (map.getLayer(ROAD_LAYER_ID)) map.setLayoutProperty(ROAD_LAYER_ID, 'visibility', roadGridVisible ? 'visible' : 'none'); }catch(_){ }
    updateRoadGridToggleLabel();
  }
  function updateRoadGridToggleLabel(){
    const b = document.getElementById('toggleRoadGridReview');
    if (b) b.textContent = roadGridVisible ? 'üõ£ –ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ —Å—ñ—Ç–∫—É –¥–æ—Ä—ñ–≥' : 'üõ£ –ü–æ–∫–∞–∑–∞—Ç–∏ —Å—ñ—Ç–∫—É –¥–æ—Ä—ñ–≥';
  }
  // === –¥–æ–≤–∂–∏–Ω–∞ –ª—ñ–Ω—ñ—ó –≤ –º–µ—Ç—Ä–∞—Ö (haversine) ===
  function pathLengthMeters(coords){
    if (!Array.isArray(coords) || coords.length < 2) return 0;
    const R = 6371000; // m
    let m = 0;
    for (let i=1;i<coords.length;i++){
      const [lon1, lat1] = coords[i-1];
      const [lon2, lat2] = coords[i];
      const œÜ1 = lat1 * Math.PI/180, œÜ2 = lat2 * Math.PI/180;
      const ŒîœÜ = (lat2-lat1) * Math.PI/180;
      const ŒîŒª = (lon2-lon1) * Math.PI/180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      m += R * c;
    }
    return m;
  }
// ---- –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è ¬´–¥–æ–º–∞–ª—å–æ–≤–∞–Ω–∏—Ö¬ª —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –∑ —Ä—ñ–∑–Ω–∏—Ö —Ñ–æ—Ä–º–∞—Ç—ñ–≤ ----
function normalizeSegments(source){
  const segments = [];
  function toLonLat(p){
    if (Array.isArray(p) && p.length>=2){
      const a=Number(p[0]), b=Number(p[1]);
      return (Math.abs(a)<=90 && Math.abs(b)<=180) ? [b,a] : [a,b];
    }
    if (p && typeof p==='object'){
      const lat=Number(p.lat ?? p.latitude), lng=Number(p.lng ?? p.lon ?? p.longitude);
      if (Number.isFinite(lat) && Number.isFinite(lng)) return [lng,lat];
    }
    if (typeof p==='string'){
      const m=p.split(/[;, ]+/).map(Number).filter(v=>!Number.isNaN(v));
      if (m.length>=2) return toLonLat(m);
    }
    return null;
  }
  function pushLine(arr){
    if (!Array.isArray(arr)) return;
    const pts = arr.map(toLonLat).filter(Boolean);
    if (pts.length>=2) segments.push(pts);
  }
  function scan(val){
    if (!val) return;
    if (val.type==='FeatureCollection' && Array.isArray(val.features)){
      val.features.forEach(f=>{
        const g=f.geometry;
        if (g?.type==='LineString') pushLine(g.coordinates);
        if (g?.type==='MultiLineString') (g.coordinates||[]).forEach(pushLine);
      });
      return;
    }
    if (val.type==='Feature' && val.geometry) return scan(val.geometry);
    if (val.type==='LineString' && Array.isArray(val.coordinates)) return pushLine(val.coordinates);
    if (val.type==='MultiLineString' && Array.isArray(val.coordinates)) return (val.coordinates||[]).forEach(pushLine);
    if (Array.isArray(val)){
      if (val.length && Array.isArray(val[0])) return pushLine(val);         // [[lng,lat],...]
      if (val.length && typeof val[0]==='object'){
        const pts = val.map(toLonLat).filter(Boolean);
        if (pts.length>=2) return segments.push(pts);
        val.forEach(scan); return;
      }
    }
    if (typeof val==='object'){
      for (const [k,v] of Object.entries(val)){
        if (/(ruler|manual|line|path|segment|polyline|draw)/i.test(k)) scan(v);
      }
    }
  }
  scan(source);
  return segments;
}

// ---- –≤—ñ–¥–º–∞–ª—å–æ–≤–∫–∞ —Å–µ–≥–º–µ–Ω—Ç—ñ–≤ –Ω–∞ –º–∞–ø—ñ (–ø—É–Ω–∫—Ç–∏—Ä, –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π) ----
let manualLayers = [];
function clearManualSegments(){
  manualLayers.forEach(id=>{
    try{ if (map.getLayer(id)) map.removeLayer(id); }catch{}
    try{ if (map.getSource(id)) map.removeSource(id); }catch{}
  });
  manualLayers = [];
}

function drawManualSegments(d){
  clearManualSegments();
  const segs = normalizeSegments(d);
  if (!segs.length) return;
  segs.forEach((coords, idx)=>{
    const id = `manual-seg-${idx}`;
    map.addSource(id, { type:'geojson', data:{ type:'Feature', geometry:{ type:'LineString', coordinates: coords } } });
    map.addLayer({
      id, type:'line', source:id,
      layout:{ 'line-cap':'round','line-join':'round' },
      paint:{ 'line-color':'#f59e0b', 'line-width':3, 'line-dasharray':[2,2] }
    });
    manualLayers.push(id);
  });
}
  // –º–∞—Ä–∫–µ—Ä–∏ –ø–æ—á–∞—Ç–∫—É/–∫—ñ–Ω—Ü—è
  let startMarker=null, endMarker=null;
  // –±–µ—Ä–µ –ª–∏—à–µ ¬´–Ω–∞–∑–≤—É¬ª –¥–æ —Ä–æ–∑–¥—ñ–ª—é–≤–∞—á–∞ ‚Ä¢ (–∞–Ω–∞–ª–æ–≥ –ª–æ–≥—ñ–∫–∏ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è)
  function parseNameFromLabel(label){
    const s = String(label||'').split('‚Ä¢')[0].trim();
    return s || '';
  }
  function setSEMarkers(points){
    try{ startMarker?.remove(); endMarker?.remove(); }catch{}
    if(!points?.length) return;
    startMarker = new mapboxgl.Marker({color:'#16a34a'}).setLngLat(points[0]).addTo(map);
    endMarker   = new mapboxgl.Marker({color:'#ef4444'}).setLngLat(points[points.length-1]).addTo(map);
  }

  async function loadRouteAndRender(){
    if (!rid){ document.getElementById('statusLine').textContent = '–ù–µ –ø–µ—Ä–µ–¥–∞–Ω–æ rid.'; return; }
        // –∫—Ä–∞—â–µ —Ç—è–≥–Ω—É—Ç–∏ –∑ —Å–µ—Ä–≤–µ—Ä–∞ (—â–æ–± –Ω–µ –∑–ª–æ–≤–∏—Ç–∏ –∫–µ—à)
    let snap = null;
    try { snap = await db.collection('routes').doc(rid).get({ source:'server' }); }
    catch { snap = await db.collection('routes').doc(rid).get(); }
     if (!snap.exists){ document.getElementById('statusLine').textContent = '–ú–∞—Ä—à—Ä—É—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.'; return; }
     const d = snap.data() || {};
    window.__lastStatus = (d.approval?.status)||'';

    document.getElementById('routeName').textContent = d.name || rid;
    document.getElementById('fromLabel').textContent = d.fromLabel || '‚Äî';
    document.getElementById('toLabel').textContent   = d.toLabel   || '‚Äî';

  // ‚ûú –æ–¥–Ω–∞ –¥–∏—Å—Ç–∞–Ω—Ü—ñ—è (–ø–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç: snapped + –ª—ñ–Ω—ñ–π–∫–∏)
  chip('chipDistanceTotal', '–ü–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç: ‚Ä¶');

    chip('chipRevision', '–ü–æ–¥–∞—á–∞ ‚Ññ ' + ((d.approval?.revision) ?? '‚Äî'));
    chip('chipStatus',   '–°—Ç–∞—Ç—É—Å: ' + fmtStatus(d.approval?.status));
	    // —è–∫—â–æ –≤–∂–µ —î —Ä—ñ—à–µ–Ω–Ω—è ‚Äî –Ω–µ –ø–æ–∫–∞–∑—É—î–º–æ –¥—ñ—ó
    const decided = ['approved','rejected'].includes(String(d.approval?.status||'').toLowerCase());
    const role = await getNormalizedRole();
    const canDecide = (role==='security' || role==='admin') && !decided;
    document.getElementById('secButtons').style.display = canDecide ? 'flex' : 'none';

    const subInfo = d.approval?.submittedAt ? `–ü–æ–¥–∞–Ω–æ: ${d.approval.submittedAt} (${d.approval.submittedByEmail||d.approval.submittedByUid||''})` : '';
    const decInfo = d.approval?.decisionAt ? ` ¬∑ –†—ñ—à–µ–Ω–Ω—è: ${d.approval.decisionAt} (${d.approval.decidedByEmail||d.approval.decidedByUid||''})` : '';
    document.getElementById('decisionInfo').textContent = subInfo + decInfo;

    document.getElementById('rejectInfo').textContent =
      (d.approval?.status==='rejected' && d.approval?.comment) ? ('–ü—Ä–∏—á–∏–Ω–∞ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è: ' + d.approval.comment) : '';

    document.getElementById('openEditor').href = '/index.html?rid=' + encodeURIComponent(rid);
    document.getElementById('statusLine').textContent = '–ú–∞—Ä—à—Ä—É—Ç –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.';

    // --- snapped –º–∞—Ä—à—Ä—É—Ç + dashed rulers ---
        // ‚öôÔ∏è fallback –ø–æ –ø–æ–ª—è—Ö —ñ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è
    const pts =
      normalizePoints(d.points) ||
      normalizePoints(d.coordinates) ||
      normalizePoints(d.route) ||
      normalizePoints(d.geojson) ||
      normalizePoints(d.geometry) ||
      fromObjPoints(d.points||[]) || [];
    CURRENT_ROUTE_POINTS = Array.isArray(pts) ? pts.slice() : [];
    LAST_ROUTE_DOC = d; // –∑–±–µ—Ä–µ–∂–µ–º–æ –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è style.load
  const routeMeters = await drawSnappedRoute(pts);
    setSEMarkers(pts);
    drawRulers(d);
	drawManualSegments(d);

    // –î–æ–≤–∂–∏–Ω–∞ –ª—ñ–Ω—ñ–π–æ–∫ (–ø—Ä—è–º—ñ –ª—ñ–Ω—ñ—ó –∑–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞)
  const rs = fromObjPoints(d.startRuler||[]);
  const re = fromObjPoints(d.endRuler||[]);
  CURRENT_START_RULER = Array.isArray(rs) ? rs.slice() : [];
  CURRENT_END_RULER   = Array.isArray(re) ? re.slice() : [];
    const totalMeters = (routeMeters||0) + pathLengthMeters(rs) + pathLengthMeters(re);
    const kmTotal = totalMeters/1000;
    chip('chipDistanceTotal', isFinite(kmTotal) ? `–ü–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç: ${kmTotal.toFixed(2)} –∫–º` : '–ü–æ–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç: ‚Äî');

    // Proposal overlay (if exists)
    try{
      const prop = d.proposal || null;
      if (prop){
        ensureProposalLayers();
        loadProposalToDraw(prop); // also updates preview + chip
      } else {
        setProposalSources([],[],[]);
        const chip = document.getElementById('chipProposal'); if (chip) chip.textContent = '–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—è: ‚Äî';
      }
    }catch(_){ }

    // –ü—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è ‚Äî –¥–æ–¥–∞—Ç–∏ –¥–æ—Ä–æ–∂–Ω—é —Å—ñ—Ç–∫—É
    addRoadGridLayer(); setRoadGridVisibility(true);

    // === –ì–µ–æ–∑–æ–Ω–∏ FROM/TO (—è–∫—â–æ tilesets –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω—ñ) ===
    try{ await loadTilesetsConfigOnce(); addTilesets(); ensureHighlightLayers(); updateHighlightsForRoute(d); setGeozonesVisibility(true); }catch(_){ }
  }

  // Approve / Reject actions (–ø–µ—Ä–µ—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –Ω–∞ –±–æ—Ü—ñ –∫–ª—ñ—î–Ω—Ç–∞ –ø–æ —Ä–æ–ª—è—Ö)
  async function applyDecision(kind, comment){
    const role = String(window.__userRole || 'user').trim().toLowerCase();
	const allowed = (role === 'security' || role === 'admin');
    if (!allowed){
      alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø—Ä–∞–≤ –¥–ª—è —Ü—ñ—î—ó –¥—ñ—ó.');
      return;
    }
    const decided = ['approved','rejected'].includes(String(window.__lastStatus||'').toLowerCase());
    if (decided){ alert('–†—ñ—à–µ–Ω–Ω—è –≤–∂–µ –ø—Ä–∏–π–Ω—è—Ç–æ. –û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É.'); return; }

    const approveBtn = document.getElementById('approveBtn');
    const rejectBtn  = document.getElementById('rejectBtn');
    approveBtn.disabled = true; rejectBtn.disabled = true;
    const user = auth.currentUser;
    const ref = db.collection('routes').doc(rid);
    // –æ—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –¥–∞–Ω—ñ –¥–ª—è –ø–æ–±—É–¥–æ–≤–∏ –¥–∏—Ñ—É –≤ –ª–æ–≥–∞—Ö
    let prevData = null;
    try{ const s = await ref.get({ source:'server' }); prevData = s.exists ? (s.data()||null) : null; }catch(_){ try{ const s2 = await ref.get(); prevData = s2.exists ? (s2.data()||null) : null; }catch(__){} }
    const payload = {
      approval: {
        status: kind,
        decisionAt: new Date().toISOString(),
        decidedByUid: user?.uid || null,
        decidedByEmail: user?.email || null,
        comment: kind === 'approved' ? null : (comment || '')
      },
      updatedAt: new Date().toISOString()
    };
    try{
      await ref.set(payload, { merge:true });
      try{
        const nextData = Object.assign({}, prevData||{}, payload);
        const prevTrack = pickTrackedFields(prevData||{});
        const nextTrack = pickTrackedFields(nextData||{});
        const changes = diffFields(prevTrack, nextTrack).filter(c => c.field !== 'updatedAt');
        const summary = buildChangeSummary(changes);
        await clientWriteRouteLog(rid, 'updated', { approvalStatus: kind, changes, summary, via:'client' });
      }catch(_){ }
    }catch(e){
      // –Ø–∫—â–æ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ –ø—Ä–∞–≤–∏–ª–∞–º–∏ ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–µ—Ä–≤–µ—Ä–Ω–∏–π fallback
      const code = (e && e.code) || (e && e.message) || '';
      if (String(code).includes('permission') || String(code).includes('denied')){
        try{
          const token = await auth.currentUser.getIdToken();
          const body = { id: rid, decision: kind, comment: (comment || '') };
          // 1) –ü–µ—Ä—à–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç ‚Äî —á–µ—Ä–µ–∑ —Ö–æ—Å—Ç–∏–Ω–≥ rewrite
          let r = await fetch('/api/routes/approve', {
            method:'POST', headers:{ 'Content-Type':'application/json', 'Authorization': 'Bearer ' + token }, body: JSON.stringify(body)
          });
          if (!r.ok){
            const txt = await r.text().catch(()=> '');
            throw new Error('Server approve failed: ' + txt);
          }
          const ct = (r.headers.get('content-type')||'').toLowerCase();
          let resp = null;
          if (!ct.includes('application/json')){
            // 2) –§–æ–ª–±–µ–∫ –Ω–∞–ø—Ä—è–º—É –Ω–∞ Cloud Functions –¥–æ–º–µ–Ω (–±–µ–∑ —Ö–æ—Å—Ç–∏–Ω–≥—É)
            const proj = (window.APP_CONFIG && window.APP_CONFIG.firebase && window.APP_CONFIG.firebase.projectId) || '';
            const url2 = proj ? `https://us-central1-${proj}.cloudfunctions.net/approveRoute` : '';
            if (!url2) throw new Error('–ï–Ω–¥–ø–æ—ñ–Ω—Ç /api/routes/approve –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —ñ projectId –≤—ñ–¥—Å—É—Ç–Ω—ñ–π –¥–ª—è –ø—Ä—è–º–æ–≥–æ –≤–∏–∫–ª–∏–∫—É.');
            r = await fetch(url2, { method:'POST', headers:{ 'Content-Type':'application/json', 'Authorization': 'Bearer ' + token }, body: JSON.stringify(body) });
            if (!r.ok){ const txt2 = await r.text().catch(()=> ''); throw new Error('Server direct approve failed: ' + txt2); }
            const ct2 = (r.headers.get('content-type')||'').toLowerCase();
            if (!ct2.includes('application/json')){ const txt2 = await r.text().catch(()=> ''); throw new Error('–ü—Ä—è–º–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø–æ–≤–µ—Ä–Ω—É–ª–∞ –Ω–µ-JSON: ' + txt2.slice(0,200)); }
            resp = await r.json().catch(()=> null);
          } else {
            resp = await r.json().catch(()=> null);
          }
          if (!resp || resp.ok !== true){ throw new Error('Server approve failed: ' + JSON.stringify(resp)); }
          try{
            const nextData = Object.assign({}, prevData||{}, payload);
            const prevTrack = pickTrackedFields(prevData||{});
            const nextTrack = pickTrackedFields(nextData||{});
            const changes = diffFields(prevTrack, nextTrack).filter(c => c.field !== 'updatedAt');
            const summary = buildChangeSummary(changes);
            await clientWriteRouteLog(rid, 'updated', { approvalStatus: kind, changes, summary, via:'client-fallback' });
          }catch(_){ }
        }catch(err){
          console.error('Approve fallback error', err);
          alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è: ' + (err?.message || err));
          approveBtn.disabled = false; rejectBtn.disabled = false;
          return;
        }
      } else {
        console.error('Approve error', e);
        alert('–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è: ' + (e?.message || e));
        approveBtn.disabled = false; rejectBtn.disabled = false;
        return;
      }
    }

    // .–û–ø—Ç–∏–º—ñ—Å—Ç–∏—á–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è UI: —Å—Ö–æ–≤–∞—Ç–∏ –∫–Ω–æ–ø–∫–∏, –æ–Ω–æ–≤–∏—Ç–∏ —á—ñ–ø —Å—Ç–∞—Ç—É—Å—É, —â–æ–± –Ω–µ –±—É–ª–æ –≤—ñ–¥—á—É—Ç—Ç—è, —â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–º—ñ–Ω–∏–ª–æ—Å—å
    try{
      window.__lastStatus = kind;
      document.getElementById('secButtons').style.display = 'none';
      document.getElementById('chipStatus').textContent = '–°—Ç–∞—Ç—É—Å: ' + (kind==='approved' ? '–ü–æ–≥–æ–¥–∂–µ–Ω–æ' : '–í—ñ–¥—Ö–∏–ª–µ–Ω–æ');
    }catch(_){ }

    // –ü—ñ—Å–ª—è –∑–∞–ø–∏—Å—É –ø—ñ–¥–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –¥–æ–∫—É–º–µ–Ω—Ç —ñ–∑ —Å–µ—Ä–≤–µ—Ä–∞ –∑ –Ω–µ–≤–µ–ª–∏–∫–∏–º –ø–æ–≤—Ç–æ—Ä–æ–º (—â–æ–± –¥–æ—á–µ–∫–∞—Ç–∏—Å—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ)
    const tryReload = async (tries=3)=>{
      for (let i=0;i<tries;i++){
        await loadRouteAndRender();
        if (String(window.__lastStatus||'').toLowerCase() === String(kind)) return true;
        await new Promise(r=>setTimeout(r, 300));
      }
      return false;
    };
    await tryReload(4);

    alert(kind === 'approved' ? '–ü–æ–≥–æ–¥–∂–µ–Ω–æ ‚úÖ' : '–í—ñ–¥—Ö–∏–ª–µ–Ω–æ ‚ùå');
    document.getElementById('rejectWrap').style.display = 'none';
    document.getElementById('rejectComment').value = '';
    approveBtn.disabled = false; rejectBtn.disabled = false;
  }

  // ---- Lightweight client-side route_logs writer (Spark safe) ----
  async function clientWriteRouteLog(routeId, type, extra){
    if (!db) return;
    const payload = Object.assign({
      routeId,
      type: type || 'updated',
      ts: new Date().toISOString(),
      actor: {
        updatedByUid: auth?.currentUser?.uid || null,
        updatedByEmail: auth?.currentUser?.email || null
      }
    }, extra || {});
    try{ await db.collection('route_logs').add(payload); }
    catch(e){ try{ console.warn('route_logs write failed:', e?.code || '', e?.message || e); }catch(_){ } }
  }

  // ---- Helpers to build readable change logs on Spark ----
  function pickTrackedFields(d){
    d = d || {};
    return {
      routeKey: d.routeKey || '',
      hub: d.hub || '',
      fromCode: d.fromCode || '',
      toCode: d.toCode || '',
      fromName: d.fromName || d.fromLabel || '',
      toName: d.toName || d.toLabel || '',
      routeType: d.routeType || '',
      distance_km: (typeof d.distance_km === 'number') ? d.distance_km : null,
      logisticName: d.logisticName || '',
      logisticId: d.logisticId || '',
      approvalStatus: (d.approval && (d.approval.status ?? d.approval.result ?? d.approval.decision)) || d.approvalStatus || d.approved || d.status || '',
      updatedAt: d.updatedAt || null
    };
  }
  function diffFields(prev, next){
    const changes = [];
    const keys = new Set([...Object.keys(prev||{}), ...Object.keys(next||{})]);
    const pretty = v => (typeof v === 'number' && Number.isFinite(v)) ? v : (v ?? '');
    for (const k of keys){
      const was = prev ? prev[k] : undefined;
      const now = next ? next[k] : undefined;
      const eq = (was === now) || (was == null && now == null);
      if (!eq) changes.push({ field:k, was: pretty(was), now: pretty(now) });
    }
    return changes;
  }
  function buildChangeSummary(changes){
    if (!Array.isArray(changes) || !changes.length) return '';
    const important = ['distance_km','routeType','approvalStatus','hub','fromCode','toCode','fromName','toName','routeKey','logisticName'];
    const labels = {
      distance_km: '–í—ñ–¥—Å—Ç–∞–Ω—å',
      routeType: '–¢–∏–ø –º–∞—Ä—à—Ä—É—Ç—É',
      approvalStatus: '–°—Ç–∞—Ç—É—Å –ø–æ–≥–æ–¥–∂–µ–Ω–Ω—è',
      hub: '–•–∞–±',
      fromCode: '–ö–æ–¥ ¬´–∑¬ª',
      toCode: '–ö–æ–¥ ¬´–¥–æ¬ª',
      fromName: '–ù–∞–∑–≤–∞ ¬´–∑¬ª',
      toName: '–ù–∞–∑–≤–∞ ¬´–¥–æ¬ª',
      routeKey: '–ö–æ–¥ –º–∞—Ä—à—Ä—É—Ç—É',
      logisticName: '–õ–æ–≥—ñ—Å—Ç',
      logisticId: 'ID –ª–æ–≥—ñ—Å—Ç–∞'
    };
    const fmt = (field, v) => {
      if (v === undefined || v === null || v === '') return '‚Äî';
      if (field === 'distance_km' && typeof v === 'number' && Number.isFinite(v)) return v.toFixed(2) + ' –∫–º';
      return String(v);
    };
    const items = changes
      .slice()
      .sort((a,b)=> (important.indexOf(a.field) === -1 ? 999 : important.indexOf(a.field)) - (important.indexOf(b.field) === -1 ? 999 : important.indexOf(b.field)))
      .map(c => {
        const label = labels[c.field] || c.field;
        const was = fmt(c.field, c.was);
        const now = fmt(c.field, c.now);
        if (c.field === 'distance_km') return `–ó–º—ñ–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ: –±—É–ª–æ ${was} ‚Üí —Å—Ç–∞–ª–æ ${now}`;
        return `${label}: –±—É–ª–æ ${was} ‚Üí —Å—Ç–∞–ª–æ ${now}`;
      });
    return items.join('; ');
  }

  // === –ù–∏–∂–Ω—ñ–π onAuthStateChanged: UI —Ç–∞ –¥–∞–Ω—ñ, —Ä–æ–ª—å —É–∂–µ –≤ window.__userRole ===
  auth.onAuthStateChanged(async (u)=>{
    const hello = document.getElementById('hello');
    if (!u){
      hello.textContent = '–ù–µ —É–≤—ñ–π—à–ª–∏';
      location.replace('/login.html?next=' + encodeURIComponent(location.pathname + location.search));
      return;
    }
    {
      const dn = (u && typeof u.displayName === 'string' && u.displayName.trim())
        ? u.displayName.trim()
        : (`–•—Ç–æ—Å—å –Ω–µ –º—ñ—Å—Ü–µ–≤–∏–π —ñ ${u.email || u.uid}`);
      hello.textContent = '–£–≤—ñ–π—à–ª–∏ —è–∫ ' + dn;
    }

    const role = await getNormalizedRole();
	const sec = (role === 'security' || role === 'admin');
	document.getElementById('secButtons').style.display = sec ? 'flex' : 'none';

    // bind buttons
    document.getElementById('approveBtn').onclick = ()=>applyDecision('approved', null);
    document.getElementById('rejectBtn').onclick  = ()=>{
      document.getElementById('rejectWrap').style.display = 'block';
      document.getElementById('rejectComment').focus();
    };
    document.getElementById('sendReject').onclick = ()=>{
      const txt = (document.getElementById('rejectComment').value||'').trim();
      if (!txt){ alert('–í–∫–∞–∂—ñ—Ç—å –ø—Ä–∏—á–∏–Ω—É –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è.'); return; }
      applyDecision('rejected', txt);
    };
    document.getElementById('cancelReject').onclick = ()=>{
      document.getElementById('rejectWrap').style.display = 'none';
    };

    updateLayoutHeights();
    await loadRouteAndRender();

    // Enable proposal tools for security/admin
    const tools = document.getElementById('proposalTools');
    if (sec && tools){ tools.style.display = 'flex'; ensureDrawOnce(); }
    // Wire proposal tool buttons
    const propEditToggle = document.getElementById('propEditToggle');
    if (propEditToggle){
      propEditToggle.onclick = () => {
        proposalEditOn = !proposalEditOn;
        // draw is always attached; we just show hint via active state
        resetProposalEditUI();
        if (proposalEditOn) ensureFeatureForKind(proposalMode);
      };
    }
    const modeBtns = {
      propModeRoute: 'route', propModeStart: 'start', propModeEnd: 'end'
    };
    Object.entries(modeBtns).forEach(([id, mode])=>{
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.onclick = () => {
        proposalMode = mode; resetProposalEditUI(); if (proposalEditOn) ensureFeatureForKind(proposalMode);
        // –∞–≤—Ç–æ-–∫–∞–¥—Ä—É–≤–∞–Ω–Ω—è –¥–æ –ø–æ—á–∞—Ç–∫—É/–∫—ñ–Ω—Ü—è –º–∞—Ä—à—Ä—É—Ç—É
        try{
          if (mode==='start' && CURRENT_ROUTE_POINTS && CURRENT_ROUTE_POINTS.length){ map.flyTo({ center: CURRENT_ROUTE_POINTS[0], zoom: 14 }); }
          if (mode==='end'   && CURRENT_ROUTE_POINTS && CURRENT_ROUTE_POINTS.length){ map.flyTo({ center: CURRENT_ROUTE_POINTS[CURRENT_ROUTE_POINTS.length-1], zoom: 14 }); }
        }catch(_){ }
      };
    });
    const propSave = document.getElementById('propSave'); if (propSave) propSave.onclick = saveProposal;
    const propClear= document.getElementById('propClear'); if (propClear) propClear.onclick = clearProposal;
  const roadBtn = document.getElementById('toggleRoadGridReview'); if (roadBtn){ roadBtn.onclick = ()=> setRoadGridVisibility(!roadGridVisible); updateRoadGridToggleLabel(); }
  const gzBtn = document.getElementById('toggleGeozonesReview'); if (gzBtn){ gzBtn.onclick = ()=> setGeozonesVisibility(!__geozonesVisible); updateGeozonesToggleLabel(); }
    const propFromCurrent = document.getElementById('propFromCurrent');
    if (propFromCurrent){
      propFromCurrent.onclick = () => {
        const has = !!(draw && draw.getAll && draw.getAll().features && draw.getAll().features.length);
        if (has && !confirm('–ó–∞–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ç–æ—á–Ω—É –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é –∫–æ–ø—ñ—î—é –º–∞—Ä—à—Ä—É—Ç—É?')) return;
        ensureDrawOnce();
        try{ draw.deleteAll(); }catch(_){ }
        if (CURRENT_ROUTE_POINTS && CURRENT_ROUTE_POINTS.length >= 2){
          upsertDrawLine('route', CURRENT_ROUTE_POINTS.slice());
          if (CURRENT_START_RULER && CURRENT_START_RULER.length >= 2) upsertDrawLine('start', CURRENT_START_RULER.slice());
          if (CURRENT_END_RULER   && CURRENT_END_RULER.length   >= 2) upsertDrawLine('end',   CURRENT_END_RULER.slice());
          proposalEditOn = true;
          proposalMode = 'route';
          resetProposalEditUI();
          ensureFeatureForKind('route');
          updateProposalPreview();
        } else {
          alert('–ü–æ—Ç–æ—á–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç –Ω–µ –º—ñ—Å—Ç–∏—Ç—å –¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ç–æ—á–æ–∫.');
        }
      };
    }

    // Click-to-append: –ø—Ä–∞—Ü—é—î —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Ü–µ –Ω–µ –±—É–≤ –ø–∞–Ω –∫–∞—Ä—Ç–∏ —ñ –∫–æ–ª–∏ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–µ –ø–æ –≤–µ—Ä—à–∏–Ω–∞–º/—Å–µ—Ä–µ–¥–Ω—ñ–º —Ç–æ—á–∫–∞–º
    map.on('click', (ev) => {
      if (!proposalEditOn) return;
      // —è–∫—â–æ —â–æ–π–Ω–æ –±—É–≤ drag –ø–∞–Ω ‚Äî —ñ–≥–Ω–æ—Ä—É—î–º–æ ¬´–∫–ª—ñ–∫¬ª –ø—ñ—Å–ª—è –ø–∞–Ω—É
      if (__isMapDragging || (Date.now() - __lastDragEndAt) < 120) return;

      // üîÅ –Ø–∫—â–æ –æ—á—ñ–∫—É—î–º–æ –∫–ª—ñ–∫ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ (–ø—ñ—Å–ª—è –≤–∏–±–æ—Ä—É –∑ –º–µ–Ω—é) ‚Äî –≤—Å—Ç–∞–≤–ª—è—î–º–æ —Å–∞–º–µ —Ç—É—Ç
      if (__pendingInsert){
        const pending = __pendingInsert; setPendingInsert(null);
        const ll = [ev.lngLat.lng, ev.lngLat.lat];
        let coords = getDrawCoordsBy(pending.kind) || [];
        if (!coords.length){ upsertDrawLine(pending.kind, [ll]); updateProposalPreview(); return; }
        const i = Math.max(0, Math.min(pending.index, coords.length-1));
        const pos = pending.dir === 'before' ? i : (i+1);
        const c = coords.slice(); c.splice(pos, 0, ll);
        upsertDrawLine(pending.kind, mergeNearDuplicates(c));
        const id = propIds[pending.kind]; if (id){ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }
        updateProposalPreview();
        return;
      }

      // —è–∫—â–æ –∫–ª—ñ–∫ –ø–æ –≤–µ—Ä—à–∏–Ω–∞—Ö/—Å–µ—Ä–µ–¥–Ω—ñ—Ö —Ç–æ—á–∫–∞—Ö Draw ‚Äî –¥–∞—î–º–æ Draw —Å–∞–º–æ–º—É –æ–±—Ä–æ–±–∏—Ç–∏ (–≤—Å—Ç–∞–≤–∫–∞/–ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è)
      try{
        const pt = [ev.point.x, ev.point.y];
        const probeLayers = [
          'gl-draw-point-inactive','gl-draw-point-active',
          'gl-draw-polygon-and-line-vertex-active','gl-draw-polygon-and-line-vertex-halo-active'
        ].filter(id => map.getLayer(id));
        const feats = probeLayers.length ? map.queryRenderedFeatures(ev.point, { layers: probeLayers }) : [];
        if (feats && feats.length) return; // –Ω–µ—Ö–∞–π Draw –æ–±—Ä–æ–±–∏—Ç—å —Å–∞–º
      }catch(_){ }

      ensureDrawOnce();
      const ll = [ev.lngLat.lng, ev.lngLat.lat];
      let coords = getDrawCoordsBy(proposalMode) || [];
      // –ù–û–í–ï: —Å–ø–æ—á–∞—Ç–∫—É –ø—Ä–æ–±—É—î–º–æ –≤—Å—Ç–∞–≤–∏—Ç–∏ —É –Ω–∞–π–±–ª–∏–∂—á–∏–π —Å–µ–≥–º–µ–Ω—Ç (–≤–µ–ª–∏–∫–∏–π –ø–æ—Ä—ñ–≥),
      // —ñ –ª–∏—à–µ —è–∫—â–æ –Ω–µ —Å–ø—Ä–∞—Ü—é–≤–∞–ª–æ ‚Äî —Ä—É—Ö–∞—î–º–æ –∫—ñ–Ω—Ü—ñ –∞–±–æ –¥–æ–¥–∞—î–º–æ –≤ –∫—ñ–Ω–µ—Ü—å.
      const SEG_PX = 28; // –ø–æ—Ä—ñ–≥ –±–ª–∏–∑—å–∫–æ—Å—Ç—ñ –¥–æ –ª—ñ–Ω—ñ—ó (–º–æ–∂–Ω–∞ –∑–±—ñ–ª—å—à–∏—Ç–∏ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏)
      const END_PX = 12; // –ø–æ—Ä—ñ–≥ –¥–ª—è –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –ø–µ—Ä./–æ—Å—Ç. –≤–µ—Ä—à–∏–Ω–∏
      if (coords.length >= 2){
        const { idx, distPx } = nearestSegmentPx(coords, ll);
        if (idx >= 0 && distPx <= SEG_PX){
          const c = coords.slice();
          c.splice(idx+1, 0, ll);
          upsertDrawLine(proposalMode, mergeNearDuplicates(c));
          const id = propIds[proposalMode]; if (id){ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }
          updateProposalPreview(); return;
        }
      }
      // —è–∫—â–æ –Ω–µ –ø–æ—Ä—É—á —ñ–∑ –∂–æ–¥–Ω–∏–º —Å–µ–≥–º–µ–Ω—Ç–æ–º ‚Äî —Å–ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –∫—ñ–Ω—Ü—ñ, —è–∫—â–æ –¥—É–∂–µ –±–ª–∏–∑—å–∫–æ
      if (coords.length >= 1){
        if (pxDist(ll, coords[coords.length-1]) <= END_PX){
          const c = coords.slice(); c[c.length-1] = ll; upsertDrawLine(proposalMode, mergeNearDuplicates(c));
          const id = propIds[proposalMode]; if (id){ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }
          updateProposalPreview(); return;
        }
        if (pxDist(ll, coords[0]) <= END_PX){
          const c = coords.slice(); c[0] = ll; upsertDrawLine(proposalMode, mergeNearDuplicates(c));
          const id = propIds[proposalMode]; if (id){ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }
          updateProposalPreview(); return;
        }
      }
      // —ñ–Ω–∞–∫—à–µ ‚Äî –¥–æ–¥–∞—î–º–æ –≤ –∫—ñ–Ω–µ—Ü—å
      upsertDrawLine(proposalMode, mergeNearDuplicates(coords.concat([ll])));
      const id = propIds[proposalMode];
      if (id){ try{ draw.changeMode('direct_select', { featureId: id }); }catch(_){ } }
      updateProposalPreview();
    });
  });
</script>
<script>
  /* ==== –ì–µ–æ–∑–æ–Ω–∏ FROM/TO (—Å–ø—Ä–æ—â–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è –∑ index.html) ==== */
  let TILESETS = [];
  let __tilesetsLoaded = false;
  async function loadTilesetsConfigOnce(){
    if (__tilesetsLoaded) return; try{
      // –ø—Ä–æ–±—É—î–º–æ —Å–µ—Ä–≤–µ—Ä–Ω–∏–π –∫–æ–Ω—Ñ—ñ–≥
      let fromFs = null;
      try{
        const doc = await firebase.firestore().collection('config').doc('tilesets').get({ source:'server' });
        if (doc.exists){ const data=doc.data(); if (Array.isArray(data)) fromFs=data; else if (data && Array.isArray(data.tilesets)) fromFs=data.tilesets; }
      }catch(_){ }
      if (Array.isArray(fromFs) && fromFs.length){ TILESETS = fromFs; }
      else{
        try{ const r = await fetch('/config/tilesets.json?v=' + Date.now()); if (r.ok){ const j = await r.json(); TILESETS = Array.isArray(j) ? j : (Array.isArray(j?.tilesets) ? j.tilesets : []); } }
        catch(_){ TILESETS = []; }
      }
    } finally { __tilesetsLoaded = true; }
  }
  let TS_FILL_IDS = []; let HL_IDS_FROM = []; let HL_IDS_TO = []; let HL_LABEL_IDS_FROM=[]; let HL_LABEL_IDS_TO=[];
  function addTilesets(){
    TILESETS.forEach(ts =>{
      const srcId = `geozones-tileset-${ts.key}`;
      if (!map.getSource(srcId)) map.addSource(srcId, { type:'vector', url: ts.url });
      const fillId = `tileset-fill-${ts.key}`;
      if (!map.getLayer(fillId)) map.addLayer({ id: fillId, type:'fill', source: srcId, 'source-layer': ts.layer, paint:{ 'fill-color':'#22c55e','fill-opacity':0.12 } });
      const outlineId = `tileset-outline-${ts.key}`;
      if (!map.getLayer(outlineId)) map.addLayer({ id: outlineId, type:'line', source: srcId, 'source-layer': ts.layer, paint:{ 'line-color':'#16a34a','line-width':1 } });
      TS_FILL_IDS.push(fillId);
      (window.TS_OUTLINE_IDS || (window.TS_OUTLINE_IDS=[])).push(outlineId);
    });
  }
  function ensureHighlightLayers(){
    TILESETS.forEach(ts=>{
      const srcId = `geozones-tileset-${ts.key}`; if (!map.getSource(srcId)) return;
      const mk = t=>`tileset-hl-${t}-${ts.key}`;
      if (!map.getLayer(mk('from'))) map.addLayer({ id:mk('from'), type:'fill', source:srcId, 'source-layer':ts.layer, filter:['==',['get','__never__'],1], paint:{ 'fill-color':'#3b82f6', 'fill-opacity':0.45 } });
      if (!map.getLayer(mk('to')))   map.addLayer({ id:mk('to'),   type:'fill', source:srcId, 'source-layer':ts.layer, filter:['==',['get','__never__'],1], paint:{ 'fill-color':'#f43f5e', 'fill-opacity':0.45 } });
      HL_IDS_FROM.push(mk('from')); HL_IDS_TO.push(mk('to'));
      const mkL = t=>`tileset-hl-${t}-label-${ts.key}`;
      const textExpr = ['coalesce', ['get','Name'], ['get','name'], ['get','–ù–∞–∑–≤–∞'], ['get','–ù–∞–∑–≤–∞ –ø–æ–ª—è'], ['get','Code'], ['get','code']];
      if (!map.getLayer(mkL('from'))) map.addLayer({ id:mkL('from'), type:'symbol', source:srcId, 'source-layer':ts.layer, filter:['==',['get','__never__'],1], layout:{ 'text-field': textExpr, 'text-size':12 }, paint:{ 'text-halo-color':'#fff','text-halo-width':1.2 } });
      if (!map.getLayer(mkL('to')))   map.addLayer({ id:mkL('to'),   type:'symbol', source:srcId, 'source-layer':ts.layer, filter:['==',['get','__never__'],1], layout:{ 'text-field': textExpr, 'text-size':12 }, paint:{ 'text-halo-color':'#fff','text-halo-width':1.2 } });
      HL_LABEL_IDS_FROM.push(mkL('from')); HL_LABEL_IDS_TO.push(mkL('to'));
    });
  }
  function buildAnyMatch(keys, value){
    if (value === null || value === undefined) return null;
    const vRaw = String(value).trim();
    if (!vRaw) return null;
    const vLower = vRaw.toLowerCase();
    const parts = keys.map(k => ['==', ['downcase', ['coalesce', ['to-string', ['get', k]], '' ]], vLower]);
    return parts.length===1 ? parts[0] : ['any', ...parts];
  }
  function buildNameCodeFilter(nameVal, codeVal){
    const NAME_KEYS = ['Name','name','NAME','–ù–∞–∑–≤–∞','–ù–∞–∑–≤–∞ –ø–æ–ª—è','Title','title','Label','label','NAME_UA','–ù–∞–∑–≤–∞ —É–∫—Ä','–ù–∞–∑–≤–∞_—É–∫—Ä'];
    const CODE_KEYS = ['Code','code','CODE','–ö–æ–¥','Id','ID','OBJECTID','OBJECT_ID','gid','GID'];
    const n = buildAnyMatch(NAME_KEYS, nameVal);
    const c = buildAnyMatch(CODE_KEYS, codeVal);
    if (n && c) return ['any', n, c]; if (n) return n; if (c) return c; return ['==',['get','__never__'],1];
  }
  function updateHighlightsForRoute(d){
    try{
      const fromName = parseNameFromLabel(d.fromLabel) || d.fromName || '';
      const toName   = parseNameFromLabel(d.toLabel)   || d.toName   || '';
      const fromCode = d.fromCode  || '';
      const toCode   = d.toCode    || '';
      const fromFilter = buildNameCodeFilter(fromName, fromCode);
      const toFilter   = buildNameCodeFilter(toName, toCode);
      HL_IDS_FROM.forEach(id=>{ if(map.getLayer(id)) map.setFilter(id, fromFilter); });
      HL_IDS_TO.forEach(id  =>{ if(map.getLayer(id)) map.setFilter(id, toFilter); });
      HL_LABEL_IDS_FROM.forEach(id=>{ if(map.getLayer(id)) map.setFilter(id, fromFilter); });
      HL_LABEL_IDS_TO.forEach(id  =>{ if(map.getLayer(id)) map.setFilter(id, toFilter); });
    }catch(_){ }
  }
  // === –¢—É–º–±–ª–µ—Ä –≥–µ–æ–∑–æ–Ω ===
  let __geozonesVisible = true;
  function setLayerVisibility(id, vis){ try{ if(map.getLayer(id)) map.setLayoutProperty(id,'visibility', vis?'visible':'none'); }catch(_){ } }
  function setGeozonesVisibility(v){
    __geozonesVisible = !!v;
    const all = [...(TS_FILL_IDS||[]),...((window.TS_OUTLINE_IDS)||[]),...(HL_IDS_FROM||[]),...(HL_IDS_TO||[]),...(HL_LABEL_IDS_FROM||[]),...(HL_LABEL_IDS_TO||[])];
    all.forEach(id => setLayerVisibility(id, __geozonesVisible));
    updateGeozonesToggleLabel();
  }
  function updateGeozonesToggleLabel(){
    const b = document.getElementById('toggleGeozonesReview');
    if (b) b.textContent = __geozonesVisible ? 'üó∫ –ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ –≥–µ–æ–∑–æ–Ω–∏' : 'üó∫ –ü–æ–∫–∞–∑–∞—Ç–∏ –≥–µ–æ–∑–æ–Ω–∏';
  }
</script>
<script>
  window.addEventListener('error', ()=>{ document.documentElement.style.visibility='visible'; });
  window.addEventListener('unhandledrejection', ()=>{ document.documentElement.style.visibility='visible'; });
</script>
</body>
</html>
